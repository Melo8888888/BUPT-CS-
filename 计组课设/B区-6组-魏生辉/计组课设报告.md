# 计组课设报告

## 摘要 

本项目基于Verilog HDL，在TEC-8实验平台上，成功设计、实现并验证了一款顺序硬连线控制器和一款两级流水硬连线控制器。

**我们的核心成果包括：**

- **功能增强的顺序控制器**：不仅实现了全部基础指令，还成功扩展了`OUT`, `MOV`, `CMP`, `NOT`四条新指令，并实现了PC指针的任意跳转功能。
- **双方案解决流水线冒险**：这是本项目的最大亮点。针对流水线设计的核心难题——控制冒险与数据冒险，我们设计并完整实现了**两种不同设计哲学的解决方案**：

- - **方案一（显式信号法）**：通过独立的`CONFLICT`信号进行模块化检测，逻辑清晰，职责分明。
  - **方案二（状态机法）**：通过集成的`GET`/`EXE`流水级状态机进行控制，代码紧凑，整体性强。 
  - 两种方案均通过了包含连续跳转和数据相关的复杂循环压力测试，证明了其在解决“吞指令”和资源冲突问题上的有效性与准确性。

- **深度调试与验证**：我们系统性地解决了从时序竞争冒险到物理硬件故障在内的一系列棘手问题,并且通过三重测试验证。

最终，我们的程序验收时在硬件平台上稳定运行，行为完全符合预期。本项目不仅让我们掌握了CPU设计全流程，更通过对流水线冒险的深度探索和双重实现，使我们对计算机体系结构的核心思想有了远超理论层面的深刻理解。

<div style="page-break-after:always;"></div>



## 目录

[TOC]

<div style="page-break-after:always;"></div>

## 1课题硬件环境及总体描述

### 1.1. 硬件平台介绍

- **核心芯片： Altera EPM7128**

本项目的设计核心是基于Altera公司的MAX 7000系列EPM7128S型复杂可编程逻辑器件（CPLD）。该芯片基于电可擦除只读存储器（EEPROM）工艺，具有非易失性、高密度和可在线编程的特点，下面是课程PPT给出的部分引脚图，在实际的测试中，我们为了验证LONG等 信号的有效性还使用了其余部分引脚表，如图2。

![img](https://cdn.nlark.com/yuque/0/2025/png/50742919/1751559517938-1a9572a2-81d7-4784-b64d-b3c4393f3184.png)

![img](https://cdn.nlark.com/yuque/0/2025/png/50742919/1751559680624-883783ae-e9c5-471c-be09-9ded18fca549.png)

- **实验系统： TEC-8计算机硬件综合实验系统**:
- TEC-8 模型计算机框图如下所示：



![img](https://cdn.nlark.com/yuque/0/2025/png/50742919/1751559280380-0a7374fb-aba5-4a9c-83a4-668b62ba51f8.png)

- TEC-8 模型计算机基础时序波形如下所示：

- ![img](https://cdn.nlark.com/yuque/0/2025/png/50742919/1751559848970-e41689db-34d5-4eeb-8524-30eb25b6b655.png)

- 说明：TEC-8 模型计算机的时序采用不定长的机器周期，大部分微指令包含 2 个机器 周期 W1 和 W2，本课设中只有存取操作涉及了 3 个机器周期 。

  <div style="page-break-after:always;"></div>

### 1.2. 课题任务与目标

- **总体目标**：掌握Verilog编程、硬件调试与复杂数字系统设计方法， 培养学生的科学研究和工程实践能力，加深对CPU各模块工作原理及相 互联系，清晰建立计算机的整机概念。
- **完成情况概况**： 本项目圆满完成了预设的全部设计与验证目标。我们成功设计、实现并充分验证了两种不同架构的CPU控制器，具体成果如下：

​    1.顺序硬连线控制器：我们成功构建了一个功能完备的顺序执行控制器。在此基础上，我们还完成了功能扩展：不仅成功增加了 `OUT`, `MOV`, `CMP`, `NOT` 四条实用指令，还实现了PC指针的任意跳转功能。

​    2.两级流水硬连线控制器：在顺序控制器的基础上，我们成功将其改造为“取指-执行”两级流水线结构。项目的核心亮点在于，我们深入研究了流水线技术中最关键的冒险问题，并为此设计和验证了<u>两种不同思路的解决方案</u>：

- - - 方案一（基于显式冲突信号）：通过模块化的逻辑，设计了专门的`CONFLICT`信号来实时检测冒险，并利用状态寄存器(`CONFLICT_REG`)锁存冲突状态，以精确控制流水线的暂停。
    - 方案二（基于流水级状态机）：采用集成化的设计思想，将流水线的“取指”与“执行”阶段抽象为`GET`/`EXE`两个核心状态，并将冒险判断逻辑内聚于状态机的转移条件中，实现了更为紧凑的控制。
  
  3.系统调试与多重验证：我们经历了系统化的调试流程，解决了包括时序竞争冒险、控制信号遗漏、乃至平台物理硬件故障在内的多类典型问题。最终，通过设计从基础指令到复杂循环的三层递进式测试样例，我们在TEC-8实验平台上全面验证了两种控制器的所有功能，证明了设计的正确性、稳定性性，特别是流水线控制器在处理连续跳转等复杂情况下的冒险处理能力得到了充分检验。

​       

<div style="page-break-after:always;"></div>

------

## 2. 课题①：顺序硬连线控制器设

### 2.1. 需求分析

- - **基础功能需求：** 按照给定数据格式、指令系统和数据通路，根据所提供的器件要求，以 Verilog

设计实现基于硬布线控制器的顺序模型处理器。根据设计方案，在实验平台上进行组装、调试并运行成功

- - **附加功能需求：**

- - - **指令扩展：** 在原有指令集基础上，成功扩展了`OUT`, `MOV`, `CMP`, `NOT`等4条新指令。 
    - **PC功能修改：** 实现了PC指针的任意跳转功能。 

### 2.2. 概要设计 

- - **核心设计思路：** 由于时间紧,考虑到可靠性和开发效率，除了对ST0的处理，我们大部分代码选择采用组合逻辑电路来设计控制器。 
  - **控制器信号定义：**

![img](https://cdn.nlark.com/yuque/0/2025/png/49695074/1751551035082-44360441-8146-42ff-82dd-03f50a865459.png)

- - - 输入信号：工作模式开关

`SW`、指令寄存器`IR`、时钟`T_clk_3`, `W_clk`、标志位`c`, `z`等。 

- - - 输出信号：总线控制、寄存器加载、存储器读写、运算器控制等微命令信号。 

![img](https://cdn.nlark.com/yuque/__puml/0a619f28458f894eb2d6afc7f76f04dd.svg)

- - **设计参考：** 参照了`TEC-8/TEC-PLUS 硬布线控制器流程图`进行微命令的逻辑设计。![img](https://cdn.nlark.com/yuque/0/2025/png/49695074/1751552780854-68b9fac5-886a-4851-a997-9d6de93f7578.png)

<div style="page-break-after:always;"></div>

### 2.3. 设计详解

#### 基础功能实现

我们严格按照**读存储器、写存储器、读寄存器、写寄存器、执行周期**的顺序来设计

![image-20250705110315250](C:\Users\w3202\AppData\Roaming\Typora\typora-user-images\image-20250705110315250.png)





##### 2.3.1 写寄存器 (`SW = 100`)



![img](https://cdn.nlark.com/yuque/__puml/c9544063b74feb58ace747e796f57a98.svg)

- **构思**：

- - **阶段划分**：`ST0=0`定义为第一阶段（写R0, R1），`ST0=1`为第二阶段（写R2, R3）。我们通过在第一阶段的W2节拍（即`W_clk[1]`有效时）置位`SST0`信号，来触发`ST0`状态的翻转，从而自动进入第二阶段。

```verilog
// 在W2节拍，当SW=100且ST0=0时，SST0有效，用于触发ST0变为1
assign SST0 = ... | ((SW == 3'b100) & !ST0 & W_clk[1]);
```

- - **寄存器选择**：根据课程PPT,我们通过`SEL`信号来精确选择当前要读和写的寄存器。在`always`块中，我们设计了一个`case`语句，它以`{W_clk[1:0], ST0}`的组合值为索引，为四个不同的节拍生成精确的`SEL`控制码。例如，在第一阶段的W1节拍（`{01, 0}` -> `3'b010`），我们设置`SEL = 4'b0011`，意为“选择写入R0，同时读出R3”。

```verilog
if(SW == 3'b100) begin
    case ({W_clk[1:0],ST0})
        3'b010: SEL = 4'b0011; // W1, ST0=0: 写R0, 读R3
        3'b100: SEL = 4'b0100; // W2, ST0=0: 写R1, 读R0
        3'b011: SEL = 4'b1001; // W1, ST0=1: 写R2, 读R1
        3'b101: SEL = 4'b1110; // W2, ST0=1: 写R3, 读R2
        ...
    endcase
end
```

##### 2.3.2 读寄存器 (`SW = 011`)

![img](https://cdn.nlark.com/yuque/__puml/28167380d60698efca23df89e66293b0.svg)

- **构思**：根据课程PPT,我们利用W1和W2两个节拍（`W_clk[0]`和`W_clk[1]`）来切换不同的寄存器选择组合。

- - 在W1节拍，`case (W_clk[1:0])`匹配到`2'b01`，我们输出`SEL = 4'b0001`，使得R0和R1的内容分别送到ALU的A、B端口，并显示在对应的指示灯上。
  - 在W2节拍，case匹配到`2'b10`，我们切换`SEL`为`4'b1011`，转而显示R2和R3的内容。

##### 2.3.3 写存储器 (`SW = 001`)

![img](https://cdn.nlark.com/yuque/__puml/c488147de7cf8365970e280efa1595ac.svg)

根据课程PPT,,我们利用`ST0`状态位来区分“设置首地址”和“连续写入”两个阶段。

- **构思**：

1. 1. **第一阶段 (ST0=0) - 指定首地址**: 用户将拨码开关`SW`拨至`001`。此时`ST0`为0，在第一个W1时钟（`W_clk[0]`）到来时，我们的`assign LAR`逻辑中的`((SW_MEM & !ST0 & W_clk[0]))`条件满足，`LAR`信号有效，将外部开关上的值载入地址寄存器AR。同时，`SST0`也被置位，为进入下一阶段做准备。
   2. **第二阶段 (ST0=1) - 连续写入**: `ST0`变为1后，系统进入一个循环状态。在每个W1时钟，`assign MEMW`的`((SW == 3'b001) & ST0 & W_clk[0])`条件会满足，执行写操作。与此同时，`assign ARINC`的逻辑 `(SW_MEM & ST0 & W_clk[0])`也满足，`ARINC`信号有效，使地址寄存器AR自动加一，指向下一个存储单元，从而实现了连续写入。

##### 2.3.4 读存储器 (`SW = 010`)



![img](https://cdn.nlark.com/yuque/__puml/f214c350c88762e56cc89735e3735357.svg)

- **构思与实现**：其流程与写存储器完全一致，也分为`ST0=0`的地址设置阶段和`ST0=1`的连续读取阶段。唯一的区别在于第二阶段的控制信号。

- - 在`ST0=1`的循环阶段，我们激活的不再是`MEMW`，而是`MBUS`信号。`assign MBUS`中的`((SW == 3'b010) & ST0 & W_clk[0])`条件会在每个W1时钟满足，将当前地址单元的数据读到数据总线上以供观察。同时，`ARINC`信号同样有效，实现地址的自动递增。

##### 2.3.5 执行指令 (`SW = 000`)

![img](https://cdn.nlark.com/yuque/0/2025/png/49695074/1751650534583-7ca40bcf-7074-44e5-9552-4915a9022160.png)



- **构思与实现**：

- - **取指阶段 (W1 /** `W_clk[0]`**)**: 我们将取指周期固定在W1节拍。如流程图所示，此时控制器发出`PCINC`和`LIR`信号。`assign PCINC = is_IR & W_clk[0];`这行代码的构思是，只要在自动执行模式下，每个W1节拍都默认执行PC自增和取指令这两个动作。
  - **执行阶段 (W2-W3 /** `W_lk[1-2]`**)**: 取指完成后，`IR`中的指令码会立即通过我们庞大的组合逻辑网络进行译码，并根据具体指令（如`ADD`, `LD`），在W2或W3节拍发出流程图中指定的控制信号序列，完成一次执行。执行完毕后，系统等待下一个W1节拍，开始新一轮的取指循环。

#### 附加功能实现

为实现拓展功能,我们修改了流程图

![img](https://cdn.nlark.com/yuque/0/2025/png/49695074/1751559185286-6b3b2cdb-9fba-4498-a622-259d84e6fc1c.png)

##### 2.3.6 扩展的四条指令

为了提升CPU的处理能力，我们基于原有架构，在流程图的蓝色高亮区域预留了操作码空间，并成功实现了多条新指令。

![img](https://cdn.nlark.com/yuque/0/2025/png/49695074/1751643234913-2f2f82fc-b752-4ee1-af0e-60b0204486c5.png)

- **构思**：我们的扩展策略是，在`case (IR[7:4])`译码逻辑中，为新的操作码添加分支。
- **以**`CMP` **(1100)为例**：通过ALU的直通模式(1010) 将源寄存器数据无损传递到输出端口，同时激活总线控制信号，确保数据能够正确地从CPU内部传输到外部接口。

- - **以**`CMP` **(1100)为例**：我们的设计思路是执行一次减法但只影响标志位，不改变寄存器的值。为此，我们设置`S=4'b0110`（减法），并正常激活`LDZ`和`LDC`。
  - `MOV` **(1011) /** `NOT` **(1101)**：同样，我们为它们分配了ALU功能码（`1010`为直通，`0000`为取反），并在`assign ABUS`和`assign DRW`的逻辑中加入了对这两个操作码的判断，使其能在W2节拍完成数据从源寄存器到目标寄存器的传送。

**指令扩展的Verilog实现**：

**1. OUT指令(1010)扩展实现：**

```plain
// ALU功能选择 - 数据直通传递
4'b1010: S = 4'b1010;

// 相关控制信号
assign ABUS = is_IR & (W_clk[1] & ((IR[7:4] == 4'b1010) | /* 其他指令 */));
assign M = is_IR & (((IR[7:4] == 4'b1010) | /* 其他内存操作 */) & W_clk[1]);
```

**2. MOV指令(1011)扩展实现：**

```plain
// ALU功能选择 - 寄存器间数据传送
4'b1011: S = 4'b1010;

// 数据写回控制
assign DRW = W_clk[1] & (is_IR & ((IR[7:4] == 4'b1011) | /* 其他写指令 */));
assign M = is_IR & (((IR[7:4] == 4'b1011) | /* 其他内存操作 */) & W_clk[1]);
```

**3. CMP指令(0011)扩展实现：**

```plain
// ALU功能选择 - 减法比较运算
4'b0011: S = 4'b1011;

// 标志位更新（不写回数据结果）
assign LDZ = W_clk[1] & is_IR & ((IR[7:4] == 4'b0011) | /* 其他影响零标志的指令 */) & T_clk_3;
assign M = is_IR & (((IR[7:4] == 4'b0011) | /* 其他内存操作 */) & W_clk[1]);
// 注意：CMP不包含在DRW中，仅更新标志位
```

**4. NOT指令(1101)扩展实现：**

```plain
// ALU功能选择 - 逻辑非运算
4'b1101: S = 4'b0000;

// 结果写回和标志更新
assign DRW = W_clk[1] & (is_IR & ((IR[7:4] == 4'b1101) | /* 其他写指令 */));
assign ABUS = is_IR & (W_clk[1] & ((IR[7:4] == 4'b1101) | /* 其他指令 */));
assign M = is_IR & (((IR[7:4] == 4'b1101) | /* 其他内存操作 */) & W_clk[1]);
```

#####  

##### 2.3.7 修改PC指针功能 (`SW = 101`)

- **构思**：该功能对应流程图最右侧的独立功能框。我们构思了一条从外部开关到PC的“直通车”。

- - 当`SW`设为`101`时，`assign SBUS`的逻辑 `... | (SW == 3'b101)` 会被激活，立即将外部开关连接到S-Bus。
  - 同时，`assign LPC`的逻辑 `... | ((SW == 3'b101) & W_clk[0] & T_clk_3)` 会等待下一个W1节拍（`W_clk[0]`）的到来。
  - 一旦W1脉冲到达，`LPC`信号有效，S-Bus上的开关值便被直接锁存进PC。这是一个单周期完成的动作，高效且直接，极大地便利了我们的硬件调试工作。

**1. SW=101模式的PC手动修改：**

```plain
// SW=101单步执行模式的特殊控制
assign LPC = ((SW == 3'b101) & W_clk[0] & T_clk_3) | /* JMP指令条件 */;
assign SHORT = ((SW == 3'b101) & W_clk[0]) | /* 其他短操作 */;
assign SBUS = (SW == 3'b101) | /* 其他源总线选择 */;
assign STOP = ((SW == 3'b101) & W_clk[0]) | /* 其他停机条件 */;
```

**2. 条件跳转的PC控制：**

```plain
// JMP无条件跳转控制
assign LPC = (is_IR & (IR[7:4] == 4'b1001) & W_clk[1] & T_clk_3) | ((SW == 3'b101) & W_clk[0] & T_clk_3);

// 条件跳转的PC相对地址加法
assign PCADD = is_IR & (((IR[7:4] == 4'b0111) & (c==1)) |     // JC成功
                        ((IR[7:4] == 4'b1000) & (z==1)) |     // JZ成功  
                        (IR[7:4] == 4'b1100) |                // 保留跳转
                        (IR[7:4] == 4'b1101)) & W_clk[1];     // 扩展跳转
```



### 2.4调试过程中的问题及讨论

**问题①：**`ST0`**状态更新的竞争冒险问题**

- **问题描述：** 在设计手动单步功能时，我们最初将`ST0`状态标志位的更新放在了时钟`T3`的**上升沿**。在测试中发现，当SSTO信号有效时，本应在同一个`T3`上升沿生效的`LAR`信号却无法将地址正确打入寄存器。
- **问题分析：** 经过的细致分析，我们定位到这是一个典型的竞争冒险问题。`LAR`信号的产生依赖于`ST0`的当前状态，而`ST0`本身又在同一个时钟边沿发生变化。这导致`LAR`的逻辑在判断时，`ST0`可能还未更新到期望值，从而使`LAR`信号产生错误或无效的脉冲，地址自然无法被正确锁存。

**解决：** 我们将`ST0`状态寄存器的更新时机从`T3`的**上升沿修改为下降沿**。

```verilog
// always @(posedge T_clk_3) begin ... // 错误的实现
always @(negedge clr, negedge T_clk_3) begin // 正确的实现
  if (!clr) ST <= 1'b0;
  else if(SST) ST <= 1'b1;
  // ...
end
```

这样修改后，`ST0`的状态在`T3`周期的中间（下降沿）就已经稳定下来。当下一个`T3`上升沿到来时，`LAR`信号可以基于一个稳定且正确的`ST0`值进行判断，从而彻底解决了竞争冒险问题。

**问题②：部分控制信号遗漏**

- **问题描述：** 在进行指令功能测试时，我们发现某些指令的行为不符合预期。举例来说，在执行某些算术或访存指令后，通过TEC-8实验箱上的指示灯观察，发现数据总线或ALU的状态与预期不符。
- **问题分析：** 这是一个由于不够仔细导致的问题。在初版的控制器代码中，我们遗漏了对一些必要控制信号的逻辑赋值，例如`M`信号和`SHORT`信号等。
- **解决：** 通过观察指示灯的直观反馈，我们迅速定位到异常，并回溯检查Verilog代码。通过对比指令流程图和现有代码，我们及时地为遗漏的`M`、`SHORT`等信号补充了正确的控制逻辑，问题得以解决。

**问题③：**`LONG`**信号失效与硬件故障排查**

- **问题描述：** 这是我们遇到的最棘手、也最有价值的一个问题。在调试多周期指令（如`LD`）时，我们发现指令始终无法进入W3，导致访存失败。逻辑上，这表明用于使能多周期操作的`LONG`信号一直无效。
- **排查：**

1. 1. **初步怀疑—>软件排查**：我们最开始以为是Verilog代码或测试程序的逻辑有问题，反复检查了`LONG`信号的产生条件和状态机的跳转逻辑，但耗费大量时间后并未发现任何错误。
   2. **转向硬件验证**：在软件层面走入死胡同后，我们“气急败坏”地决定采用一种硬核的调试方法来验证信号的物理状态。我们修改了顶层代码，将内部的`LONG`信号直接引出到一个在实验板上未被复用的LED指示灯引脚。同时，为了排除是我们自身逻辑的问题，我们甚至在代码中强制将`LONG`信号置为`1` (`assign LONG = 1'b1;`)。
   3. **最终**：执行上述操作并烧录程序后，我们观察到那个被引出的LED灯**始终不亮**。这个现象证明了：问题不在于我们的控制器逻辑，而是我们正在使用的这台TEC-8实验箱存在**物理硬件故障**（可能是FPGA引脚虚焊）。

### **2.5. 设计调试小结**

在本次处理器设计中，我们不仅完成了全部功能，更在解决实际问题的过程中，积累了宝贵的硬件调试经验。我们遇到的几个典型问题及其解决思路，是本次课题最大的收获。

首先，我们深刻体会到硬布线控制器对**时序的敏感性**。初期调试`ST0`状态信号时，因其在时钟上升沿更新，与`LAR`信号的采样同步，导致了竞争冒险。我们的解决方案是将其状态更新调整至时钟下降沿，确保`ST0`在被采样前已经稳定。这次经历让我们明确了利用时钟不同边沿进行状态更新与逻辑采样，是避免时序问题的有效设计范式。

其次，调试过程也凸显了**严谨细致的重要性**。我们曾因遗漏对`M`、`SHORT`等信号的逻辑赋值，导致指令行为异常。这个问题虽然简单，但通过实验箱指示灯的直观反馈得以快速定位。这警示我们，细致的前期设计远胜于后期的反复排错，且应充分利用板载LED等资源进行快速的功能验证。

我们最大的收获，来自于一次棘手的**硬件故障排查**。在调试`LD`等多周期指令时，`LONG`信号始终无效，导致指令无法进入W3节拍。在反复检查代码无果，软件调试陷入僵局后，我们果断转向硬件验证。我们采取了“信号引出”的策略：修改顶层代码，将内部的`LONG`信号直接连接到一个空闲LED，并强制`assign LONG = 1'b1;`。烧录后LED灯不亮，这个现象无可辩驳地证明了问题源于实验箱的物理故障，而非我们的逻辑代码。这个过程教会我们，当软件调试无法解决问题时，必须有方法和勇气去怀疑并验证硬件。通过信号引出和强制赋值等方法进行硬件隔离，是区分软件逻辑与物理故障的终极排错手段。



<div style="page-break-after:always;"></div>

------

## 3. 课题②：流水硬连线控制器设计

### 3.1. 需求分析

- **需求：实现两级流水线控制器**

- - 设计的核心目标是在给定的硬件平台（TEC-8实验系统及FPGA）上，将顺序执行的处理器改造为两级流水线结构。
  - 这两级流水线分别为“取指阶段”和“执行阶段” 。
  - 其设计思想是在处理器执行当前指令的同时，并行地取出下一条将要执行的指令，从而实现取指与执行的重叠操作，以提高CPU的指令吞吐率和整体效率 。

- **主要的挑战：解决冒险**

- - 根据课程ppt，将顺序执行的处理器流水化后，最大的挑战来自于流水线冒险，事实也印证了这点。
  - **需要关注“吞指令”现象**：举个例子，当CPU执行一条`JMP`（跳转）指令时，流水线已经在执行`JMP`的同时，预取了紧跟在`JMP`后面的那条指令（位于PC+1地址）。当`JMP`执行完毕，程序计数器（PC）会跳转到一个新的地址，CPU开始从新地址取指令，而被提前取出的那条位于PC+1的指令就被错误地跳过、从未执行 。

### 3.2. 概要设计

#### 3.2.1流水线架构设计：

- -  我们设计为“取指”和“执行”两级流水线，即取下一条指令和执行当前指令重叠进行。 

![img](https://cdn.nlark.com/yuque/0/2025/png/50742919/1751548668494-1dc1439d-af0a-4010-a3f9-f34469bfdf23.png)

#### 3.2.2两种冒险处理策略：

我们总结了一下，需要处理的三种主要冒险：

1. 1. 1. **控制冒险**：由跳转指令引起。

- - - - **无条件跳转指令 (**`JMP`**)**：执行此指令会强制修改PC值，导致流水线中已经取出的下一条指令（PC+1处）变为无效，必须被冲刷掉 。
      - **条件跳转指令 (**`JC,JZ `)：当跳转条件满足时（`C=1`/`Z=1`），PC会跳转到新地址，同样导致预取指令失效，构成控制冒险 。

1. 1. 1. **结构冒险 / 数据冒险** ：由多周期指令引起。

- - - - **多周期指令 (**`LOAD`**,** `STORE`**)**：这类指令需要多个时钟周期才能完成访存等操作 。当它们在执行后续周期时，流水线必须暂停，不能取新指令。否则，新指令的取指操作会和当前指令的执行步骤（如读写存储器）发生资源冲突（例如，总线的使用权），这是一种结构冒险，也可能因数据未准备好而引发数据冒险 。

为解决流水线冒险问题，我们设计了两种不同思路的“阻塞流水线”方案。两种方案的最终目标一致，即和上文所述的——通过暂停取指来插入“气泡”，但其内部的逻辑架构和设计哲学有所不同，我们分别来介绍一下： 

**方案一：基于显式冲突信号**

此方案将冒险的“检测”、“保持”和“处理”分解为独立的逻辑模块，通过专门的控制信号进行交互。

- **1. 实时冒险检测模块 ——**`CONFLICT`**信号:**

- - 这是一个组合逻辑模块，其输出为一个关键的`CONFLICT`信号。
  - 功能：实时监控指令寄存器（`IR`）和状态标志位（`c`, `z`），一旦检测到任何需要暂停流水线的条件（如`JMP`、`JC`/`JZ`跳转或多周期指令执行），`CONFLICT`信号立即变为高电平。这实现了对所有冒险源的集中检测。

- **2. 冲突状态锁存模块 ——**`CONFLICT_REG* **/** `LONG_ENTERED`**:**

- - 为了将瞬时的`CONFLICT`信号转换为持续一个完整时钟周期的稳定“暂停”状态，我们*巧妙地*设计了一个时序逻辑模块，下面详细介绍。
  - 该模块包含了`CONFLICT_REG`和`LONG_ENTERED`两个状态寄存器，它们分别用于锁存和保持由跳转指令和多周期指令引发的冲突状态 。
  - 对于多周期的指令，也就是LOAD 和 STORE，我们的处理见下图：
  - ![img](https://cdn.nlark.com/yuque/0/2025/png/50742919/1751551000209-7a2a2b90-363e-45e3-8304-0495101f7a60.png)

- **3. 流水线暂停执行模块 ——**`PCINC`**控制:**

- - 流水线的暂停最终通过控制取指逻辑来实现。
  - 我们设计`PCINC`和`LIR`信号的产生逻辑，使其直接受控于`CONFLICT_REG`和`LONG_ENTERED`的状态。只有当这两个冲突状态寄存器都无效时，取指操作才能进行。

**方案二：基于流水级状态机**

此方案的思想是**状态驱动**，将流水线的“取指”和“执行”阶段抽象为两个可控的状态，并将冒险判断逻辑放到状态转移的条件中。

- **1. 流水级状态寄存器 ——**`GET **/** `EXE`**：**

- - 这个设计的核心是两个状态寄存器：`GET`（即取指使能）和`EXE`（即执行使能）。
  - `GET`寄存器代表“取指”阶段的状态：为`1`时允许取指，为`0`时暂停取指。
  - `EXE`寄存器代表“执行”阶段的状态：为`1`时允许执行，为`0`时抑制执行（用于冲刷流水段）。
  - 以上两个寄存器共同构成了控制流水线流动的核心状态机。

- **2. 状态转移逻辑:**

- - 设计的关键在于`GET`和`EXE`寄存器的状态转移逻辑。
  - 这里，我们不使用一个统一的`CONFLICT`信号，而是将所有冒险的判断条件直接写入这两个寄存器的`always`块中。
  - 举例来说，`GET`寄存器的状态转移逻辑会判断当前是否为跳转指令且条件满足，如果是，则在下一个时钟周期将`GET`置为`0`，从而实现取指暂停。

- **3. 微命令生成与状态驱动:**

- - 所有的取指相关微命令（例如`PCINC`, `LIR`）都与`GET`状态位相关联。
  - 所有的执行相关微命令（例如`DRW`, `M`, `ABUS`等）都与`EXE`状态位相关联。
  - 综上所述，通过控制`GET`和`EXE`这两个“总开关”，我们实现了对整个流水线的宏观调控。

### 3.3. 设计详解

#### **3.3.1 方案① —— 基于显式冲突信号**

**1. 冒险的识别：**`CONFLICT 与LONG_I ` 信号

我们首先用组合逻辑定义了两个核心的`wire`信号——`CONFLICT和LONG_I`  ，用于实时检测冒险源。

`LONG_I信号：用于识别所有需要多周期执行的指令，即`LOAD`和`STORE`。

```verilog
assign LONG_I = (IR[7:4] == 4'b0101) | (IR[7:4] == 4'b0110); // 识别 LD 和 ST
```

`CONFLICT`**信号**：这是所有冒险条件的集合。当任何一种冒险发生时，该信号立即变为1。

```verilog
assign CONFLICT = (IR[7:4] == 4'b1001) |             // 1. 无条件跳转 JMP
  ( (IR[7:4] == 4'b0111) & c ) |   // 2. 条件为真(c=1)的 JC
  ( (IR[7:4] == 4'b1000) & z ) |   // 3. 条件为真(z=1)的 JZ
  (LONG_I & !W_clk[0]);          // 4. 多周期指令的后续执行周期
```

说明：

- - 前三行处理**控制冒险**：只要是`JMP`指令，或`JC`/`JZ`指令的跳转条件得到满足，就触发冲突。
  - 最后一行处理**结构/数据冒险**：`LONG_I`表示当前是`LD`/`ST`指令，而`!W_clk[0]`表示当前不是第一个工作周期（`w1`），说明指令正在占用总线进行后续操作，此时必须暂停流水线以避免资源冲突。

**2.冒险状态的保持与流水线暂停：**`always` **块与** `PCINC`

检测到的瞬时冲突需要被锁存，以形成持续整个时钟周期的稳定“暂停”信号。这里我们是通过一个`always`块实现的：

```verilog
always @(negedge CLR, posedge T_clk_3) begin
  if(!CLR) begin
    CONFLICT_REG <= 1'b0;
    LONG_ENTERED <= 1'b0;
  end
  else if(CONFLICT & !CONFLICT_REG) begin // 捕获新发生的冲突
    CONFLICT_REG <= 1'b1;
  end
  else if(LONG_I & !LONG_ENTERED & W_clk[0]) begin // 捕获新进入的多周期指令
    LONG_ENTERED <= 1'b1;
  end
  else begin // 无新冲突，或冲突已处理完毕，清零
    CONFLICT_REG <= 1'b0;
    LONG_ENTERED <= 1'b0;
  end
end
```

- `CONFLICT_REG`和`LONG_ENTERED`是两个状态寄存器，分别用于锁存跳转冲突和多周期指令冲突。
- `if(CONFLICT & !CONFLICT_REG)`这个条件是精髓：它只在`CONFLICT`信号**首次**变为1的那一刻为真，从而将`CONFLICT_REG`置位。在下一个周期，即使`CONFLICT`消失，`CONFLICT_REG`也会保持为1，直到在`else`块中被清零。这确保了暂停信号能稳定地持续一个完整的时钟周期。`LONG_ENTERED`的逻辑与此类似。

最终，流水线的暂停通过控制`PCINC`信号实现。

```verilog
assign PCINC = is_IR & (!CONFLICT_REG) & (!LONG_ENTERED);
assign LIR = PCINC; // 取指信号与PC自增同步
```

- 说明：只有在当前是自动工作模式（`is_IR`），且**没有任何冲突状态**（`!CONFLICT_REG`和`!LONG_ENTERED`都为真）时，PC才自增，流水线才取入新指令。否则，取指阶段被“冻结”，实现“插入气泡”的效果。

**3. 关于**`POP`**信号**

为了防止在暂停的瞬间，ALU的旧计算结果错误地更新标志位，我们用组合逻辑设计`POP`信号。

```verilog
assign POP = (CONFLICT & !CONFLICT_REG) | (LONG_I & !LONG_ENTERED & W_clk[0]);
assign LDC = is_IR & !POP & ( ... );
assign LDZ = !POP & is_IR & ( ... );
```

- 说明：`POP`信号的逻辑与`always`块中捕获新冲突的条件完全一致，因此它是一个**只在冲突发生瞬间有效**的脉冲信号。
- 在`LDC`和`LDZ`的逻辑中，我们用`!POP`作为***“门卫”***。在`POP`有效的那一刻，这个门会关闭，阻止对标志位寄存器的写入，从而规避了错误状态的锁存。

![img](https://cdn.nlark.com/yuque/__puml/395d9e51fcfa5b7bd36a3d32fed0028b.svg)

#### **3.3.2 方案②：基于流水级状态机的集成化实现**

这个方案将冒险处理逻辑完全集成到了两个核心状态寄存器`GET`和`EXE`的控制中，可以说形成一个紧凑的状态机。

**1. 流水线状态机的核心 ——**`GET`**与**`EXE`

- `reg GET`：定义为“取指使能”状态位。`GET=1`表示取指阶段正常工作，`GET=0`表示暂停。
- `reg EXE`：定义为“执行使能”状态位。`EXE=1`表示执行阶段正常工作，`EXE=0`表示冲刷或暂停。

**2. 状态转移逻辑**

所有的冒险判断都直接体现在`GET`和`EXE`的状态转移中：

`**GET**寄存器的控制逻辑：

```verilog
always @(negedge T3, negedge CLR) begin
  // ...
  // 当跳转条件满足时，暂停取指
  else if(GET & ((is_jc&C&is_fetch&STO)|(is_jz&Z&is_fetch&STO)|(is_jmp&is_fetch&STO)))
    GET <= 1'b0;
  // 当多周期指令开始执行时，也暂停取指
  else if(GET & is_fetch & STO & (is_st|is_ld) & !w1)
    GET <= 1'b0;
  // 在合适的时机恢复取指
  else if(!GET & ... )
    GET <= 1'b1;
  // ...
end
```

- - 该`always`块就是一个状态机，当它检测到`JMP`或`LD`/`ST`等指令时，直接在下一个时钟周期将`GET`置为`0`，从而**主动进入暂停状态**。

**3.状态机驱动下的流水线控制**

流水线的启停完全由`GET`和`EXE`的状态决定。

**取指控制**：

```verilog
assign PCINC = (is_fetch & STO & (w1|w2|w3) & GET);
assign LIR = is_fetch & STO & (w1|w2|w3) & GET;
```

- - 当`GET`被状态机置为`0`时，`PCINC`和`LIR`信号自然变为无效，取指阶段被暂停。

**执行控制**：

```verilog
assign ABUS = EXE & (is_fetch & STO & ...);
assign DRW  = ( ... ) | (is_fetch & STO & ... & EXE & ...);
assign LDC  = is_fetch & STO & ... & EXE;
assign LDZ  = is_fetch & STO & ... & EXE;
```

说明：

- - 几乎所有的执行阶段信号都与`EXE`信号相与。当发生跳转，需要冲刷掉流水线中已取出的无效指令时，状态机可以将`EXE`置为`0`，从而**禁止整个执行阶段的所有操作**。
  - **隐式地解决了错误更新标志位的问题**：由于`LDC`和`LDZ`同样受`EXE`控制，当执行阶段被抑制时，它们也自然无法写入，无需像方案①那样设计额外的`POP`信号。

![img](https://cdn.nlark.com/yuque/__puml/f5dcba4b3510b0a4127368bcba832cd8.svg)

#### 3.3.4 两种冒险处理方案总结

|                    | 方案一：基于显式冲突信号                                     | 方案二：基于流水级状态机                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **核心思想**       | **功能模块化、信号驱动**。将冒险的“检测”、“保持”和“处理”分解为独立的逻辑模块。 | **状态驱动、集成化**。将冒险处理逻辑融入到控制流水线阶段的状态机中。 |
| **冒险检测方式**   | **显式检测**。通过专门的组合逻辑信号 `CONFLICT` 实时监控所有冒险源。 | **隐式检测**。冒险条件作为状态机（`GET`/`EXE`寄存器）状态转移的一部分，没有设立统一的冲突信号。 |
| **暂停机制实现**   | 通过 `CONFLICT_REG` 等寄存器**锁存**瞬时冲突信号，生成稳定的暂停控制信号，再用该信号去**门控**`PCINC`。 | 通过状态机**主动进入“暂停”状态**（如将 `GET` 置为0），`PCINC` 等信号因状态位的改变而自然失效。 |
| **对错误写的处理** | **显式处理**。专门设计了 `POP` 信号，在冲突发生的瞬间主动阻止对标志位寄存器 `LDC`/`LDZ` 的写入。 | **隐式处理**。通过将执行阶段使能信号 `EXE` 置为0，来禁止**所有**执行阶段的操作，其中自然也包括了对 `LDC`/`LDZ` 的写入。 |

### 3.4 调试过程中的问题及讨论

- - ***问题①：***

- - - **问题①：** 在流水线设计初期，我们实现了基本的暂停机制但在测试跳转指令 ，但我们没有想到引入POP气泡信号， 在实现流水线暂停时，发现即使暂停了取指，跳转指令瞬间仍可能将错误的状态写入标志位寄存器。
    - **解决① ： 引入**`POP`**信号，在检测到冲突的时候，立即阻止LDC,/LDZ的加载，防止错误状态被锁存。** 



- - ***问题②：***

- - - **问题②：** 在引入`POP`信号的初步设计中，我们将其实现为了一个**时序逻辑信号，**然而，在后续测试中，我们惊愕地发现问题依旧存在：错误的标志位依然有概率被写入。`POP`信号似乎总是慢了半拍，没能起到预期的瞬时阻止作用。 
    -  要解决这个竞争问题，**阻拦信号必须和被阻拦的信号一样快**。因此，我们必须将`POP`信号从时序逻辑改为组合逻辑。
    - **错误的实现 (时序逻辑):**

```verilog
// reg POP; 
// always @(posedge T_clk_3) begin
//    POP <= (CONFLICT & !CONFLICT_REG) | ... ; // 存在延迟
// end
```

- - - **正确的实现 (改为组合逻辑):**

```verilog
wire POP; // 将POP定义为线网类型
assign POP = (CONFLICT & !CONFLICT_REG) | (LONG_I & !LONG_ENTERED & W_clk[0]);
```

通过使用`assign`语句，`POP`信号的电平不再依赖于时钟边沿，而是直接、瞬时地跟随其输入的变化。当`CONFLICT`在周期`T_n`内变为高电平，`POP`也**在同一周期内立即变为高电平。**



- - ***问题③：***

- - - **问题③：** Quartus II 烧录代码 的问题
    - **解决③ ：**在修改流水线代码的过程中，我们发现烧录代码可能不会生效，后来每次发现必须新开一次窗口。



- - ***问题④：***

- - - **问题③：** w1,w2,w3灯突然不亮的问题
    - **解决③ ：**很抽象的问题，第一天不亮，第二天好像就莫名其妙好了。

### 3.5. 设计调试小结

**设计层面**，我们成功实现了两种不同哲学思想的流水线冒险处理方案。

- **方案①（显式信号法）**：通过将冒险的“检测-保持-处理”流程分解为`CONFLICT`、`CONFLICT_REG`和`POP`等独立信号，我们能够清晰地构建和验证每一步逻辑。这种方法虽然信号较多，写的时候花了很长时间，但职责分明，为后续的调试提供了极大的便利。
- **方案二②（状态机法）**：通过将整个控制器视为一个由`GET`和`EXE`驱动的状态机，我们将复杂的判断逻辑内聚在一起，代码更为紧凑。这要求我们对所有可能的输入和状态组合进行周全的考虑，从而对状态机的设计与实现有了更深入的把握。

**在调试层面**，我们遇到的挑战同样具有启发性。

- 从最初未能处理跳转指令的标志位污染问题，到引入`POP`信号进行精确“狙击”，再到最终发现`POP`信号必须由时序逻辑改为组合逻辑才能解决竞争冒险，这一系列过程让我们对硬件描述语言中的**时序和实时性**有了刻骨铭心的认识。

- 此外，我们也遇到了一些与开发环境相关的问题，如Quartus II软件的代码更新机制和实验箱硬件的间歇性故障。这些看似“抽象”的问题锻炼了我们系统排错的能力，让我们学会了在面对不确定性时，采用“控制变量”、“重启大法”等多种方法来定位和隔离问题，这或许也是硬件工程师必备的素养罢。

  <div style="page-break-after:always;"></div>

------

## 4. 总体测试

### 4.1. 测试方案

 为全面、严谨地验证我们设计的顺序及流水线控制器的正确性，我们制定了一套由简到繁、层层递进的测试方案。所有测试均在TEC-8实验平台上完成，几乎覆盖了所有指令，`dp=0`和`dp=1`两种工作模式测试均已通过。

**测试策略**

我们的测试策略主要围绕以下几个核心目标展开：

指令覆盖度：确保我们支持的每一条指令，包括基础指令和扩展指令（`NOT`, `MOV`等），都至少被测试一次，以验证其基本功能的正确性。

数据路径验证：通过设计不同的源和目的操作数，全面测试寄存器与寄存器、寄存器与存储器之间的数据通路是否通畅。

控制逻辑验证：重点测试控制冒险，设计包含`JMP`、`JC`, `JZ`的序列，验证PC指针能否正确更新，以及跳转条件是否被精确判断。

流水线的验证：针对流水线控制器，我们设计了包含连续跳转和数据相关的复杂循环样例，以高压力、高强度的测试来检验我们冒险处理逻辑的完备性，确保不会出现“吞指令”或状态错误等问题。

### 4.2 测试样例①——基础样例

**初始状态:**

- **寄存器:**`r0 = 00001000`, `r1 = 00000100`
- **存储器:**`Mem[00000100] = 00000001`
- **程序计数器 (PC):**`PC` 从 `00H` 开始

| 步骤 (PC)     | 指令          | 指令码       | 说明          | 执行后 r0 值 | 执行后 r1 值 | 执行后 PC 值 |
| ------------- | ------------- | ------------ | ------------- | ------------ | ------------ | ------------ |
| **初始**      | -             | -            | 系统初始状态  | `00001000`   | `00000100`   | `00H`        |
| **1** (`00H`) | `ADD r0, r1`  | `0001 00 01` | r0 = r0 + r1  | `00001100`   | `00000100`   | `01H`        |
| **2** (`01H`) | `SUB r0, r1`  | `0010 00 01` | r0 = r0 - r1  | `00001000`   | `00000100`   | `02H`        |
| **3** (`02H`) | `OR r0, r1`   | `1011 00 01` | r0 = r0 \| r1 | `00001100`   | `00000100`   | `03H`        |
| **4** (`03H`) | `LD r0, [r1]` | `0101 00 01` | r0 = Mem[r1]  | `00000001`   | `00000100`   | `04H`        |
| **5** (`04H`) | `MOV r1, r0`  | `1101 01 00` | r1 = r0       | `00000001`   | `00000001`   | `05H`        |
| **6** (`05H`) | `JMP r1`      | `1001 01 00` | PC = r1       | `00000001`   | `00000001`   | `01H`        |



说明：

- **步骤1-3**: `ADD`、`SUB`、`OR` 指令均能正确执行，并将运算结果写回寄存器 `r0`，验证了ALU算术和逻辑单元的功能。
- **步骤4**: `LD` 指令成功地将寄存器 `r1` 的值 (`0100H`) 作为地址，从内存中取出了预设值 `00000001` 并加载到 `r0`，验证了内存读取数据通路的正确性。
- **步骤5**: `MOV` 指令将 `r0` 的值成功复制到 `r1`，验证了寄存器间的数据转移功能。
- **步骤6**: `JMP` 指令执行后，程序计数器 `PC` 的值被正确地修改为寄存器 `r1` 的值 (`01H`)，使程序流跳转回第二条指令，验证了无条件跳转逻辑的正确性。

![img](https://cdn.nlark.com/yuque/__puml/fdcc26d219c64ab64cc3d2c6086408b0.svg)

### 4.3 测试样例②——进阶样例

进阶样例的重点是**条件跳转指令** (`JC` / `JZ`) 的正确性。旨在检验流水线在面临跳转时的处理是否正确。

**初始状态**

- **寄存器**: `r0 = 00001000`, `r1 = 00010100`
- **存储器**: `Mem[00010100] = 00000011`
- **程序计数器 (PC)**: 从 `00H` 开始
- **标志位**: `C=0`, `Z=0`

 **执行过程与结果分析**

详细的执行过程和每个步骤后的状态变化如下表所示。

| 步骤 (PC)     | 指令          | 指令码       | 说明                | 执行后 r0 值 | 执行后 r1 值 | 执行后 C/Z 标志位 | 执行后 PC 值 |
| ------------- | ------------- | ------------ | ------------------- | ------------ | ------------ | ----------------- | ------------ |
| **初始**      | -             | -            | 系统初始状态        | `00001000`   | `00010100`   | C=0, Z=0          | `00H`        |
| **1** (`00H`) | `ADD r0, r1`  | `0001 00 01` | `r0 = 00011100`     | `00011100`   | `00010100`   | C=0, Z=0          | `01H`        |
| **2** (`01H`) | `SUB r0, r1`  | `0010 00 01` | `r0 = 00001000`     | `00001000`   | `00010100`   | C=0, Z=0          | `02H`        |
| **3** (`02H`) | `LD r0, [r1]` | `0101 00 01` | `r0 = Mem[r1]`      | `00000011`   | `00010100`   | C=0, Z=0          | `03H`        |
| **4** (`03H`) | `MOV r1, r0`  | `1011 01 00` | `r1 = r0`           | `00000011`   | `00000011`   | C=0, Z=0          | `04H`        |
| **5** (`04H`) | `INC r0`      | `0100 00 00` | `r0 = r0 + 1`       | `00000100`   | `00000011`   | C=0, Z=0          | `05H`        |
| **6** (`05H`) | `JC +4`       | `0111 0100`  | `C=0`，**不跳转**   | `00000100`   | `00000011`   | C=0, Z=0          | `06H`        |
| **7** (`06H`) | `SUB r0, r0`  | `0010 00 00` | `r0=0`，**Z位置1**  | `00000000`   | `00000011`   | C=0, **Z=1**      | `07H`        |
| **8** (`07H`) | `JZ +1`       | `1000 0001`  | `Z=1`，**跳转成功** | `00000000`   | `00000011`   | C=0, Z=1          | `**0AH**`    |

**分析说明：**

该进阶样例的执行结果完全符合预期：

- 在**步骤6**，`JC`指令正确地检测到`C`标志位为0，没有执行跳转，PC正常递增。
- 在**步骤7**，`SUB r0, r0`指令成功地将`r0`清零，并正确地将`Z`标志位置为1。
- 在关键的**步骤8**，`JZ`指令正确地检测到`Z`标志位为1，执行了跳转，将PC从`08H`（执行`07H`指令后的PC值）更新为目标地址`0AH`。

![img](https://cdn.nlark.com/yuque/__puml/05541c5ee09ff7ac35fbb1f007e23b42.svg)

### 4.4 测试样例③——复杂循环样例

本测试样例是本次课程设计中**最全面、最严格**的综合性测试：

1. 覆盖绝大多数指令，包括算术、逻辑、内存访问、数据移动以及多种跳转指令。
2. 通过设计一个包含条件跳转和无条件跳转的**循环结构**，对流水线控制器的**冒险处理能力**进行压力测试。
3. 验证在连续的控制流变化下，流水线是否能正确处理控制冒险（如冲刷无效的预取指令也就是09H设计的STP）。

**初始状态**

- **寄存器**: `r0 = 00001000`, `r1 = 00010100`
- **存储器**: `Mem[00010100] = 00000011`
- **程序计数器 (PC)**: 从 `00H` 开始
- **标志位**: `C=0`, `Z=0`

**执行过程与结果分析**

程序首先会执行一系列初始化指令，然后进入一个从`06H`到`0BH`的循环体。通过在循环中修改`r1`的值，最终巧妙地跳出循环并停机。详细过程如下表所示。

| 循环       | 步骤 (PC) | 指令          | 说明                    | 执行后 r0 值 | 执行后 r1 值 | C/Z 标志位   | 执行后 PC 值 |
| ---------- | --------- | ------------- | ----------------------- | ------------ | ------------ | ------------ | ------------ |
| **初始**   | -         | -             | 系统初始状态            | `00001000`   | `00010100`   | C=0, Z=0     | `00H`        |
| **设置**   | `00H`     | `ADD r0, r1`  | `r0 = r0 + r1`          | `00011100`   | `00010100`   | C=0, Z=0     | `01H`        |
| **阶段**   | `01H`     | `SUB r0, r1`  | `r0 = r0 - r1`          | `00001000`   | `00010100`   | C=0, Z=0     | `02H`        |
|            | `02H`     | `NOT r0`      | `r0 = ~r0`              | `11110111`   | `00010100`   | C=0, Z=0     | `03H`        |
|            | `03H`     | `LD r0, [r1]` | `r0 = Mem[r1]`          | `00000011`   | `00010100`   | C=0, Z=0     | `04H`        |
|            | `04H`     | `MOV r1, r0`  | `r1 = r0`               | `00000011`   | `00000011`   | C=0, Z=0     | `05H`        |
|            | `05H`     | `INC r0`      | `r0 = r0 + 1`           | `00000100`   | `00000011`   | C=0, Z=0     | `06H`        |
| **第一次** | `06H`     | `JC +4`       | `C=0`，不跳转           | `00000100`   | `00000011`   | C=0, Z=0     | `07H`        |
| **循环**   | `07H`     | `SUB r0, r0`  | `r0=0`，**Z位置1**      | `00000000`   | `00000011`   | C=0, **Z=1** | `08H`        |
|            | `08H`     | `JZ +1`       | `Z=1`，**跳转成功**     | `00000000`   | `00000011`   | C=0, Z=1     | `0AH`        |
|            | `09H`     | `STP`         | **(被跳过)**            | -            | -            | -            | -            |
|            | `0AH`     | `ADD r1, r1`  | `r1 = r1 + r1`          | `00000000`   | `00000110`   | C=0, Z=0     | `0BH`        |
|            | `0BH`     | `JMP r1`      | `PC=r1`，**返回循环头** | `00000000`   | `00000110`   | C=0, Z=0     | `**06H**`    |
| **第二次** | `06H`     | `JC +4`       | `C=0`，不跳转           | `00000000`   | `00000110`   | C=0, Z=0     | `07H`        |
| **循环**   | `07H`     | `SUB r0, r0`  | `r0=0`，**Z位置1**      | `00000000`   | `00000110`   | C=0, **Z=1** | `08H`        |
|            | `08H`     | `JZ +1`       | `Z=1`，**跳转成功**     | `00000000`   | `00000110`   | C=0, Z=1     | `0AH`        |
|            | `09H`     | `STP`         | **(被跳过)**            | -            | -            | -            | -            |
|            | `0AH`     | `ADD r1, r1`  | `r1 = r1 + r1`          | `00000000`   | `00001100`   | C=0, Z=0     | `0BH`        |
|            | `0BH`     | `JMP r1`      | `PC=r1`，**跳出循环**   | `00000000`   | `00001100`   | C=0, Z=0     | `**0CH**`    |
| **结束**   | `0CH`     | `STP`         | **停机**                | -            | -            | -            | **停机**     |

![img](https://cdn.nlark.com/yuque/0/2025/png/50742919/1751555680853-f21b6a43-b9b2-46dd-a38d-8e8e4665f47a.png)

![img](https://cdn.nlark.com/yuque/__puml/84aeeb44a5ba42eb65f9e2cde0334ff1.svg)

**测试说明：**

该复杂样例的实际运行结果与上述流程完全一致：

1. 在两次循环中，位于`08H`的`JZ`指令都能在`Z=1`时成功跳转，并正确地跳过了位于`09H`的`STP`指令。

2. **循环逻辑正确**：程序能够根据`r1`的值正确地执行`JMP`指令，在第一次循环后返回`06H`，并在第二次循环后准确地跳出到`0CH`，说明数据通路和PC更新逻辑在连续操作下保持正确。

3. 整个程序从开始执行到最终在预定地点停机，行为完全符合预期。

   <div style="page-break-after:always;"></div>

## 5团队分工

- - **杜乐乐：** 负责第一版顺序与流水控制器大部分代码设计与调试。 
  - **代天宇：** 负责第二版顺序与流水控制器大部分代码设计与调试。 
  - **魏生辉：** 负责第一版代码部分代码设计，负责基础和进阶测试样例设计与测试、实验报告撰写。 
  - **徐鹤松：** 负责第二版代码部分代码设计，负责高阶复杂测试样例设计、实验报告撰写与ppt制作。
  - **协作说明：** 小组分工高效合理，在规定时间内并行完成了两份不同思路的代码的设计与调试。 

| 成员       | 主要分工                                                     | 贡献度 |
| ---------- | ------------------------------------------------------------ | ------ |
| **杜乐乐** | 负责第一版顺序与流水控制器大部分代码设计与调试。             | 25%    |
| **代天宇** | 负责第二版顺序与流水控制器大部分代码设计与调试。             | 25%    |
| **魏生辉** | 负责第一版代码部分代码设计，负责基础和进阶测试样例设计、实验报告编写。 | 25%    |
| **徐鹤松** | 负责第二版代码部分代码设计，负责高阶复杂测试样例设计、实验报告编写与PPT制作。 | 25%    |

<div style="page-break-after:always;"></div>

## 6. 总结

本次课程设计围绕**顺序与流水线**硬连线控制器的设计、实现与验证展开，对我们四个人来说，这是一个综合性挑战。通过本次项目，我们不仅成功地在TEC-8实验平台上构建了两个功能完备且稳定运行的CPU控制器，更在整个过程中获得了宝贵经验。

在**设计实现层面**，我们取得了显著的成果。我们不仅按要求实现了基础的顺序控制器，还主动对其进行了功能扩展，增加了多条实用指令并优化了PC功能。值得一提的是，我们成功地实现流水化，并针对流水线技术中最核心的**冒险问题**，创新性地设计、实现并对比了**两种**不同的解决方案：一种是基于`CONFLICT`等显式信号的模块化检测与控制方案，逻辑清晰，易于调试；另一种是基于`GET`/`EXE`状态位的集成化状态机方案，代码紧凑，整体性强。

在**工程调试层面**，我们经历的挑战与收获同样深刻。从解决`ST0`状态更新的竞争冒险，到通过引入并优化`POP`信号来精确处理跳转指令引发的数据污染，再到最终通过“软硬结合”的排查方法定位出实验箱的物理故障，这一系列复杂的调试过程，让我们对Verilog的时序逻辑、硬件信号的实时性以及系统级的故障排查方法论有了教科书之外的刻骨铭心的认识。

总而言之，本次课程设计不仅让我们熟练掌握了使用Verilog进行复杂数字逻辑设计的方法，更重要的是，它让我们完整地走过了一个微型CPU从概念到实物的全过程。通过亲手设计数据通路、编写控制逻辑、解决时序问题、设计测试用例，我们真正将“取指”、“译码”、“执行”、“流水线”、“冒险”等抽象概念，转化为了看得见、摸得着的硬件行为。

本次项目分工明确，团队协作高效为我们后续深入学习计算机体系结构及从事相关领域的科研与工程工作打下了坚实的基础。

**最后感谢赵老师、靳老师的指导，我们将追随前辈的脚步，直挂云帆济沧海！**

<div style="page-break-after:always;"></div>

------

## 7.附录

### 附录A: 小组各成员的心得总结

**杜乐乐心得：**

本次课程设计中我主要负责第一版代码的设计与实现，这个过程充满了挑战，也让我受益匪浅。印象最深的是初期对TEC-8时序的理解。起初，我认为简单地按照流程图编写逻辑即可，但在手动单步调试时，发现`DRW`等信号总是不稳定，这就是典型的竞争冒险。通过引入`ST0`同步状态，并利用时钟下降沿来稳定状态，我才真正理解了时序逻辑在硬件设计中的核心地位。从最初的设计屡屡碰壁，到最终顺序和流水线控制器的第一版稳定运行，这个从无到有的过程给了我巨大的成就感和信心。

**代天宇心得：**

我的主要工作是负责第二版控制器的代码设计与调试，这更多是基于第一版进行优化和重构。最大的挑战和收获来自于对流水线冒险处理方案的探索。在实现了方案一（显式`CONFLICT`信号）后，我们团队讨论能否有更集成的实现方式，这促使我设计了方案二。这个过程让我深刻体会到，对于同一个工程问题，可以有多种不同的设计哲学和实现路径。通过这个过程，我对控制器设计的状态机思想、逻辑解耦与耦合的利弊有了更为直观和深入的认识，这比单纯实现一种方案要收获得多。

**魏生辉心得：**

我在项目中主要第一版代码设计与实现，其余精力投入在测试用例的设计与执行，以及实验报告的撰写。这份工作让我认识到，验证和设计同等重要。一个微小的逻辑疏忽，比如遗漏`M`或`SHORT`信号，只有在特定指令的测试中才会暴露。我设计的基础样例和进阶样例就是为了系统性地覆盖指令集和数据通路，确保每个微命令在正确的时钟周期被触发。

当看到我们设计的复杂跳转逻辑在测试中行为完全符合预期时，那种喜悦是对我们整个团队工作的最好肯定。

**徐鹤松心得：**

我在项目中负责第二版的部分代码设计、高阶测试用例以及报告撰写+PPT的整合。对我而言，最有价值的经历是设计复杂循环测试样例。这个样例的目的就是为了给我们的流水线控制器施加最大压力，连续的`JZ`和`JMP`指令是对我们冒险处理逻辑的终极考验。当看到程序能够精准地跳过`STP`指令，并在循环两次后准确停机时，我知道我们设计的两种冒险处理方案都经受住了考验。总之，这是个艰辛且完美的体验。

<div style="page-break-after:always;"></div>

### 附录B: 第六小组调试日志

**6月30日**

在调试顺序控制器的初期，我们遇到了第一个棘手的问题。在手动单步模式下，我们发现地址寄存器的加载信号，非常不稳定，时灵时不灵，导致我们无法准确地手动写入地址或数据。

起初我们怀疑是代码逻辑错误，但反复检查无果。最终，通过逻辑分析仪挂上探针观察波形，我们才定位到根源：这是一个典型的**竞争冒险**问题。我们手动按下按钮产生的SST信号与系统时钟T_clk_3是异步的。

当SST信号的变化恰好发生在T_clk_3时钟的上升沿附近时，依赖于它的ST0状态寄存器的建立时间不足，从而导致后续的LAR信号产生错误的窄脉冲。解决方案是对外部异步信号进行同步化处理。

我们重新设计了状态产生逻辑，确保ST0状态的更新严格放在T_clk_3的**下降沿**。这样一来，在下一个时钟上升沿到来、LAR等信号需要采样ST0状态时，ST0早已稳定，这样我们彻底解决了竞争问题。

<div style="page-break-after:always;"></div>

**7月1日**

我们转向流水线控制器的调试，并立刻遇到了预料之中的核心难题——**控制冒险**。在测试JMP等跳转指令时，我们发现紧跟在跳转指令之后的那条指令总是被“吞掉”，即从未被执行。

经过分析，我们明确了问题所在：在JMP指令的执行阶段（EXE），PC已经被更新为新的目标地址；但与此同时，流水线的取指阶段（IF）已经“勤快地”根据旧的PC+1地址，将下一条无效指令提前取入了指令寄存器。当跳转生效后，这条被预取的指令理应被作废，但当时的控制器没有机制去冲刷它。

为此，我们设计并实现了方案一（显式冲突信号）。我们用组合逻辑`CONFLICT`在指令译码时就立刻识别出跳转指令，并用一个状态寄存器`CONFLICT_REG`将这个冲突信号锁存一个时钟周期。在`CONFLICT_REG`有效期间，我们强制“冻结”取指阶段（即PCINC和LIR信号无效），从而在流水线中成功插入了一个“气泡”，等待PC更新完毕，有效解决了“吞指令”问题。

<div style="page-break-after:always;"></div>

**7月2日**

在解决了基本的控制冒险后，一个更隐蔽的问题浮出水面。我们发现，在流水线因跳转而暂停时，标志位寄存器偶尔会被错误地更新。具体来说，跳转指令的**上一条**指令（比如一条SUB）的运算结果，会“穿越”一个周期，在跳转指令执行的瞬间污染标志位。问题根源在于，虽然我们暂停了PCINC，但执行阶段的ALU并没有停止工作。上一条指令的计算结果在跳转发生时依然稳定地保持在ALU的输出端。当流水线暂停时，这个旧的结果在下一个时钟沿，被错误地加载进了标志位寄存器。

为了实现精准“狙击”，我们引入了组合逻辑信号`POP`。它的产生条件与`CONFLICT_REG`的置位条件完全一致，确保它只在冲突发生的那个瞬间有效。然后，我们在加载标志位（LDC和LDZ）的逻辑中加入了`!POP`作为使能条件。这样，`POP`信号就像一个反应迅速的“门卫”，在错误数据即将写入寄存器的瞬间“砰”地把门关上，完美规避了状态污染，今天是我们最有成就感的一天。

<div style="page-break-after:always;"></div>

**7月3日**

在调试进入尾声时，我们遇到了一个最令人困惑的问题。无论是顺序控制器还是流水线控制器，多周期指令LD和ST都突然无法正确执行，它们似乎永远无法进入W3周期，导致访存操作失败。

通过观察，我们发现LONG信号恒为低电平。我们首先进行了彻底的软件排查，反复检查了Verilog代码中所有与LONG信号相关的产生逻辑，耗费了大量时间，但没有发现任何错误。在软件层面陷入僵局后，我们开始怀疑硬件本身。

为了验证，我们采取了一个直接的办法：修改顶层代码，将内部的LONG信号直接引出到一个空闲的LED灯上，并强制`assign LONG = 1'b1;`。烧录程序后，对应的LED灯依然不亮。

这个现象无可辩驳地证明了，问题并非出在我们的逻辑设计上，而是我们使用的这台TEC-8实验箱存在**物理硬件故障**，可能是CPLD引脚虚焊或内部损坏。虽然这个问题最终通过更换实验平台解决，但这次经历教会了我们系统性排错的重要性：当软件排查走不通时，必须有勇气和方法去验证硬件层面的问题。

最后，在赵老师的帮助下，我们更换了新的硬件设备，提前准备好了测试样例，静待验收。

<div style="page-break-after:always;"></div>

### 附录C: 贡献度表





<div style="page-break-after:always;"></div>

### 附录D: Verilog 核心代码

- - **版本1**

```verilog
module controller (
    input wire [2:0]SW,
    input wire [7:0]IR,
    input wire T_clk_3,
    input wire CLR,
    input wire [2:0]W_clk,
    input wire c,
    input wire z,
    output wire SBUS,//
    output reg[3:0] SEL,
    output wire SELCTL,//
    output wire DRW,//
    output wire STOP,//
    output wire MBUS,//
    output wire LAR,//
    output wire ARINC,//
    output wire SHORT,//
    output wire MEMW,//
    output wire LIR, //
    output wire PCINC, //
    output reg [3:0]S,
    output wire CIN, //
    output wire ABUS, //
    output wire LDZ,//
    output wire LDC, //
    output wire PCADD, //
    output wire LPC, //
    output wire LONG,
    output wire M
);
    
	
    wire CONFLICT;
    wire LONG_I;
    reg CONFLICT_REG;
    reg LONG_ENTERED;
    wire POP;
    assign CONFLICT = (IR[7:4] == 4'b1001) | ( (IR[7:4] == 4'b0111) & c ) | ( (IR[7:4] == 4'b1000) & z ) | (LONG_I & !W_clk[0]);
	assign LONG_I = (IR[7:4] == 4'b0101) | (IR[7:4] == 7'b0110);
    wire SST0;
    wire ST0;
    ST0_gen ST_Gen(.SST(SST0), .ST(ST0), .T_clk_3(T_clk_3),.W_1(W_clk[0]),.W_2(W_clk[1]),.SW(SW),.clr(CLR));

	wire is_WORKING;
	assign is_WORKING = W_clk[0] | W_clk[1] | W_clk[2];
    wire is_IR;
    assign is_IR = (SW == 3'd0) & is_WORKING;
    wire SW_MEM;
    assign SW_MEM = (SW == 3'b010) | (SW == 3'b001);
	
	assign POP = (CONFLICT & !CONFLICT_REG) | (LONG_I & !LONG_ENTERED & W_clk[0]);
	
	
    assign LPC = (is_IR & (IR[7:4] == 4'b1001)) | ((SW == 3'b101) & W_clk[0]);
    assign PCADD = is_IR & (( (IR[7:4] == 4'b0111) & (c==1)  )|  ((IR[7:4] == 4'b1000) & (z==1) ) );
    assign LDC = is_IR & !POP & ( (IR[7:4] == 4'b0001) | (IR[7:4] == 4'b0100) | (IR[7:4] == 4'b0010));
    assign LDZ = !POP & is_IR & ( (IR[7:4] == 4'b0001) | (IR[7:4] == 4'b0100) | (IR[7:4] == 4'b0010) | (IR[7:4] == 4'b0011) | (IR[7:4] == 4'b1100) );
    assign ABUS = is_IR & (    IR[7:6] == 2'b00 | ((IR[7:4] == 4'b0101 | IR[7:4] == 4'b0110 ) & W_clk[1]) | (IR[7:4] == 4'b0111) | (IR[7:4] == 4'b1001) | (IR[7:4] == 4'b1010) | (IR[7:4] == 4'b1011) | (IR[7:4] == 4'b1100) | (IR[7:4] == 4'b1101)   | (W_clk[2] & IR[7:4] == 4'b0110));
    assign CIN = is_IR & !POP & (IR[7:4] == 4'b0001);
    assign PCINC = is_IR  & (!CONFLICT_REG) & (!LONG_ENTERED);
    assign LIR = PCINC;
    assign MEMW =  is_IR & W_clk[2] & (IR[7:4] == 4'b0110) | ((SW == 3'b001) & ST0 & W_clk[0] );
    assign SHORT = (SW_MEM & W_clk[0]) | ((SW == 3'b101) & W_clk[0]);
    assign ARINC =  SW_MEM & ST0 & W_clk[0];
    assign LAR = (( SW_MEM & !ST0 & W_clk[0] ) | (is_IR & (IR[7:4] == 4'b0101|IR[7:4] == 4'b0110) & W_clk[1]));
    assign MBUS = ((SW == 3'b010) & ST0 & W_clk[0]) | (is_IR & (IR[7:4] == 4'b0101) & W_clk[2]);
    assign STOP = (is_IR & (IR[7:4] == 4'b1110)) | SELCTL | ((SW == 3'b101) & W_clk[0]);
    assign DRW = (SW == 3'b100) | ( is_IR & ( (IR[7:4] == 4'b0001) | (IR[7:4] == 4'b0010) | (IR[7:4] == 4'b0011) | (IR[7:4] == 4'b0100) | (IR[7:4] == 4'b1011) | (IR[7:4] == 4'b1101) ) )  | (W_clk[2] & is_IR & (IR[7:4] == 4'b0101) );
    assign SELCTL = !is_IR;
    assign SBUS = (SW == 3'b100) | (SW == 3'b001) | ((SW == 3'b010) & !ST0) | (SW == 3'b101);
    assign SST0 = (SW_MEM & !ST0 & W_clk[0]) | ((SW == 3'b100) & !ST0 & W_clk[1]);
    assign LONG = is_IR & ( (IR[7:4] == 4'b0101) | (IR[7:4] == 4'b0110) ) & W_clk[1];
    assign M = is_IR &  ( ( (IR[7:4] == 4'b0011) | (IR[7:4] == 4'b0101 & W_clk[1]) | (IR[7:4] == 4'b0110) | (IR[7:4] == 4'b1001) | (IR[7:4] == 4'b1010) | (IR[7:4] == 4'b1011) | (IR[7:4] == 4'b1101)  ) );
    
    always @(negedge CLR,posedge T_clk_3) begin
		if(!CLR) CONFLICT_REG <= 1'b0;
		else if(CONFLICT & !CONFLICT_REG) begin
			CONFLICT_REG <= 1'b1;
		end
		else if(LONG_I & !LONG_ENTERED & W_clk[0]) begin
			LONG_ENTERED <= 1'b1;
		end
		else begin
			CONFLICT_REG <= 1'b0;
			LONG_ENTERED <= 1'b0;
		end
    
    end
    
    
    
    always @(*) begin
        if(SW == 3'b100) begin
            case ({W_clk[1:0],ST0})
                3'b010: SEL = 4'b0011;
                3'b100: SEL = 4'b0100;
                3'b011: SEL = 4'b1001;
                3'b101: SEL = 4'b1110;
                default SEL = 4'b0000;
            endcase
        end
        else if(SW == 3'b011) begin
            case (W_clk[1:0])
                2'b01: SEL = 4'b0001;
                2'b10: SEL = 4'b1011;
                default SEL = 4'b0000;
            endcase
        end
        else SEL = 4'b0000;
        if (is_IR) begin
            case (IR[7:4])
                4'b0001: S = 4'b1001;
                4'b0010: S = 4'b0110;
                4'b0011: S = 4'b1011;
                4'b0100: S = 4'b0000;
                4'b0101: S = W_clk[2] ? 4'b0000 : 4'b1010;
                4'b0110: S = W_clk[2] ? 4'b1010 : 4'b1111;
                4'b1001: S = 4'b1111;
                4'b1010: S = 4'b1010;
                4'b1011: S = 4'b1010;
                4'b1100: S = 4'b0110;
                4'b1101: S = 4'b0000;
                default: S = 4'b0000;
            endcase
        end
        else begin
            S = 4'b0000;
        end
    end
endmodule
module ST0_gen (
    input wire SST,
    output reg ST,
    input wire T_clk_3,
    input wire W_1,
    input wire W_2,
    input wire clr,
    input wire[2:0] SW
);
    always @(negedge clr,negedge T_clk_3) begin
		if (!clr) ST <= 1'b0;
        else if(SST) ST <= 1'b1;
        else if (SW == 3'b100 && W_2) ST <= 1'b0;
        else ST <= ST;
    end
endmodule
```

- - **版本2**

```verilog
module controller(
	//clock
	input CLR,
	input T3,
	input w1,w2,w3,
	//
	input SWA,SWB,SWC,
	input IR7,IR6,IR5,IR4,
	input Z,C,    
	//
	output M,CIN,LDC,LDZ,
	output reg [3:0]S,
	output DRW,
	output reg [3:0]SEL,	
	output PCINC,PCADD,
	output LPC,
	output LIR,
	output LAR,
	output ARINC,
	output SELCTL,
	output MEMW,
	output STOP,
	output ABUS,MBUS,SBUS,
	output SHORT,LONG
);
	
	wire [2:0]sw={SWC,SWB,SWA};
	wire [3:0]ir={IR7,IR6,IR5,IR4};
	
	wire is_read_reg,is_write_reg,is_fetch,is_read_mem,is_write_mem,is_sto_invert;
	wire is_add,is_sub,is_and,is_inc,is_ld,is_st,is_jc,is_jz,is_jmp,is_stop,is_out,is_mov,is_cmp,is_not;
	
	assign is_read_reg=(sw==3'b011);
	assign is_write_reg=(sw==3'b100);
	assign is_fetch=(sw==3'b000);
	assign is_read_mem=(sw==3'b010);
	assign is_write_mem=(sw==3'b001);
	assign is_sto_invert=(sw==3'b101);
	
	assign is_add=(ir==4'b0001);
	assign is_sub=(ir==4'b0010);
	assign is_and=(ir==4'b0011);
	assign is_inc=(ir==4'b0100);
	assign is_ld=(ir==4'b0101);
	assign is_st=(ir==4'b0110);
	assign is_jc=(ir==4'b0111);
	assign is_jz=(ir==4'b1000);
	assign is_jmp=(ir==4'b1001);
	assign is_out=(ir==4'b1010);
	assign is_mov=(ir==4'b1011);
	assign is_cmp=(ir==4'b1100);
	assign is_not=(ir==4'b1101);
	assign is_stop=(ir==4'b1110);
	
	reg STO;
	wire SSTO;
	
	assign SSTO=(is_write_reg&w2&!STO)|(is_read_mem&w1&!STO)|(is_write_mem&w1&!STO)|(is_fetch&w2&!STO);
	
	always @(negedge T3,negedge CLR)begin
		if(!CLR)STO<=1'b0;
		else if(SSTO)STO<=1'b1;
		else if(is_sto_invert&w2)STO<=1'b0;
		else STO<=STO;
	end
	
	reg EXE;
	reg GET;
	
	always @(negedge T3,negedge CLR)begin
		if(!CLR)EXE<=1'b1;
		else if(!GET&((is_fetch&is_jc&STO)|(is_fetch&is_jz&STO)))EXE<=1'b0;
		else if(!EXE&((is_fetch&is_jc&STO)|(is_fetch&is_jz&STO)))EXE<=1'b1;
		else if(GET&is_fetch&STO&(is_st|is_ld)&!w1)EXE<=1'b0;
		else if(is_fetch&STO&(is_st|is_ld)&w1)EXE<=1'b1;
		else EXE<=EXE;
	end
	
	always @(negedge T3,negedge CLR)begin
		if(!CLR)GET<=1'b1;
		else if(GET&((is_jc&C&is_fetch&STO)|(is_jz&Z&is_fetch&STO)|(is_jmp&is_fetch&STO)))GET<=1'b0;
		else if(!GET&((is_fetch&is_jc&STO)|(is_fetch&is_jz&STO)|(is_jmp&is_fetch&STO)))GET<=1'b1;
		else if(GET&is_fetch&STO&(is_st|is_ld)&!w1)GET<=1'b0;
		else if(is_fetch&STO&(is_st|is_ld)&w1)GET<=1'b0;
		else if(!GET&is_fetch&STO&(is_st|is_ld)&w2)GET<=1'b1;
		else GET<=GET;
	end
	
	
	assign SBUS=(is_write_reg&(w1|w2))|(is_read_mem&!STO&w1)|(is_write_mem&w1)|(is_fetch&w2&!STO);
	assign SELCTL=(is_write_reg&(w1|w2))|(is_read_reg&(w1|w2));
	assign STOP=(is_write_reg&(w1|w2))|(is_read_reg&(w1|w2))|(is_write_mem&w1)|(is_read_mem&w1)|(is_sto_invert&w1)|(is_fetch&!STO&w1)|(is_fetch&(w1|w2|w3)&is_stop&STO&EXE);
	assign ABUS=EXE&(is_fetch&STO&(w1|w2|w3)&(is_add|is_sub|is_and|is_inc|(is_ld&w2)|is_st|is_jmp|is_out|is_mov|is_not));
	assign MBUS=(is_read_mem&STO&w1)|(is_fetch&STO&is_ld&w3&EXE);
	assign DRW=(is_write_reg&(w1|w2))|(is_fetch&STO&(w1|w2|w3)&EXE&(is_add|is_sub|is_and|is_inc|is_mov|is_not))|(is_fetch&STO&EXE&is_ld&w3);
	assign PCINC=(is_fetch&STO&(w1|w2|w3)&GET);
	assign LPC=(is_fetch&!STO&w2)|(is_fetch&STO&(w1|w2|w3)&is_jmp&EXE);
	assign LAR=((is_read_mem&w1&!STO)|(is_write_mem&w1&!STO)|(is_fetch&STO&w2&(is_ld|is_st)&EXE));
	assign ARINC=w1&STO&(is_read_mem|is_write_mem);
	assign MEMW=(is_write_mem&STO&w1)|(is_fetch&STO&w3&is_st&EXE);
	assign LIR=is_fetch&STO&(w1|w2|w3)&GET;
	assign LDZ=is_fetch&STO&(w1|w2|w3)&(is_add|is_sub|is_and|is_inc|is_cmp|is_not)&EXE;
	assign LDC=is_fetch&STO&(w1|w2|w3)&(is_add|is_sub|is_inc|is_cmp)&EXE;
	assign CIN=is_fetch&STO&(w1|w2|w3)&is_add&EXE;
	assign M=EXE&is_fetch&STO&(w1|w2|w3)&(is_and|is_st|(is_ld&w2)|(is_st&(w2|w3))|is_jmp|is_out|is_mov|is_not);
	assign SHORT=(is_read_mem&w1)|(is_write_mem&w1);
	assign LONG=is_fetch&STO&w2&(is_ld|is_st)&EXE;
	assign PCADD=is_fetch&STO&(w1|w2|w3)&((is_jc&C)|(is_jz&Z))&EXE;
	
	
	
	always @(*)begin
		if(is_fetch&STO&(w1|w2|w3)&(!is_ld&!is_st))begin
			case(ir) 
			4'b0001: S=4'b1001;
			4'b0010: S=4'b0110;
			4'b0011: S=4'b1011;
			4'b0100: S=4'b0000;
			4'b1001: S=4'b1111;
			4'b1010: S=4'b1010;
			4'b1011: S=4'b1010;
			4'b1100: S=4'b0110;
			4'b1101: S=4'b0000;
			default: S=4'b0000;
			endcase
		end
		else if(is_fetch&STO&w2&is_ld)S=4'b1010;
		else if(is_fetch&STO&w2&is_st)S=4'b1111;
		else if(is_fetch&STO&w3&is_st)S=4'b1010;
		else S=4'b0000;
		
		if(is_write_reg&w1&!STO)SEL=4'b0011;
		else if(is_write_reg&w2&!STO)SEL=4'b0100;
		else if(is_write_reg&w1&STO)SEL=4'b1001;
		else if(is_write_reg&w2&STO)SEL=4'b1110;
		else if(is_read_reg&w1)SEL=4'b0001;
		else if(is_read_reg&w2)SEL=4'b1011;
		else SEL=4'b0000;
	end

endmodule
```
