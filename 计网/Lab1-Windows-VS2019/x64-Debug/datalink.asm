; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34809.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__4044BF6F_concurrencysal@h DB 01H
__8CDCC27F_sal@h DB 01H
__5C92A0FF_vadefs@h DB 01H
__5C9F43E4_vcruntime@h DB 01H
__1B0272D9_corecrt@h DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__61CC25A1_errno@h DB 01H
__7E47F0EB_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__E9D055F4_datalink@h DB 01H
__10407056_stdarg@h DB 01H
__F3AB37EB_lprintf@h DB 01H
__37388F29_protocol@h DB 01H
__7E028C7C_datalink@c DB 01H
msvcjmc	ENDS
PUBLIC	main
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BL@MJDEAOHC@We?5Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BB@HNIKDDHJ@We?5Send?5ACK?5?5?$CFd?6@	; `string'
PUBLIC	??_C@_0BB@OABGPLNF@We?5Send?5NAK?5?5?$CFd?6@	; `string'
PUBLIC	??_C@_0CL@LDLCFLN@Melo?5?$CG?$CG?5Songshuyu?5?3?5May?512?52025@ ; `string'
PUBLIC	??_C@_0BP@BDPEBLLD@?$CK?$CK?$CK?$CK?5?5Error?0?5Bad?5CRC?5Checksum?6@ ; `string'
PUBLIC	??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CM@EIMHPHCN@Recv?5frame?5is?5not?5?5expected?0?5NA@ ; `string'
PUBLIC	??_C@_0CM@ILJEGABI@Put?5packet?5to?5network?5layer?5seq@ ; `string'
PUBLIC	??_C@_0BH@LFIEOPPF@Recv?5NAK?5?5?$CFd?5?9?9?$CFdbyte?6@ ; `string'
PUBLIC	??_C@_0CD@MEKNEOEC@?9?9?9?9?5DATA?5?$CFd?5timeout?0?5resend?5?9?9@ ; `string'
EXTRN	__report_rangecheckfailure:PROC
EXTRN	memcpy:PROC
EXTRN	lprintf:PROC
EXTRN	protocol_init:PROC
EXTRN	wait_for_event:PROC
EXTRN	enable_network_layer:PROC
EXTRN	disable_network_layer:PROC
EXTRN	get_packet:PROC
EXTRN	put_packet:PROC
EXTRN	recv_frame:PROC
EXTRN	send_frame:PROC
EXTRN	crc32:PROC
EXTRN	start_timer:PROC
EXTRN	stop_timer:PROC
EXTRN	start_ack_timer:PROC
EXTRN	stop_ack_timer:PROC
EXTRN	dbg_event:PROC
EXTRN	dbg_frame:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
phl_ready DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$between DD imagerel between
	DD	imagerel between+187
	DD	imagerel $unwind$between
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$put_frame DD imagerel put_frame
	DD	imagerel put_frame+115
	DD	imagerel $unwind$put_frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send__frame DD imagerel send__frame
	DD	imagerel send__frame+409
	DD	imagerel $unwind$send__frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN42
	DD	imagerel $LN42+1627
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CD@MEKNEOEC@?9?9?9?9?5DATA?5?$CFd?5timeout?0?5resend?5?9?9@
CONST	SEGMENT
??_C@_0CD@MEKNEOEC@?9?9?9?9?5DATA?5?$CFd?5timeout?0?5resend?5?9?9@ DB '--'
	DB	'-- DATA %d timeout, resend ----', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LFIEOPPF@Recv?5NAK?5?5?$CFd?5?9?9?$CFdbyte?6@
CONST	SEGMENT
??_C@_0BH@LFIEOPPF@Recv?5NAK?5?5?$CFd?5?9?9?$CFdbyte?6@ DB 'Recv NAK  %d '
	DB	'--%dbyte', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@ILJEGABI@Put?5packet?5to?5network?5layer?5seq@
CONST	SEGMENT
??_C@_0CM@ILJEGABI@Put?5packet?5to?5network?5layer?5seq@ DB 'Put packet t'
	DB	'o network layer seq:%d, ID: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EIMHPHCN@Recv?5frame?5is?5not?5?5expected?0?5NA@
CONST	SEGMENT
??_C@_0CM@EIMHPHCN@Recv?5frame?5is?5not?5?5expected?0?5NA@ DB 'Recv frame'
	DB	' is not  expected, NAK sent back', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Recv DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@ DB 'Recv ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BDPEBLLD@?$CK?$CK?$CK?$CK?5?5Error?0?5Bad?5CRC?5Checksum?6@
CONST	SEGMENT
??_C@_0BP@BDPEBLLD@?$CK?$CK?$CK?$CK?5?5Error?0?5Bad?5CRC?5Checksum?6@ DB '*'
	DB	'***  Error, Bad CRC Checksum', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LDLCFLN@Melo?5?$CG?$CG?5Songshuyu?5?3?5May?512?52025@
CONST	SEGMENT
??_C@_0CL@LDLCFLN@Melo?5?$CG?$CG?5Songshuyu?5?3?5May?512?52025@ DB 'Melo '
	DB	'&& Songshuyu : May 12 2025  21:56:13', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OABGPLNF@We?5Send?5NAK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BB@OABGPLNF@We?5Send?5NAK?5?5?$CFd?6@ DB 'We Send NAK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNIKDDHJ@We?5Send?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BB@HNIKDDHJ@We?5Send?5ACK?5?5?$CFd?6@ DB 'We Send ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MJDEAOHC@We?5Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BL@MJDEAOHC@We?5Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'We Se'
	DB	'nd DATA %d %d, ID %d', 0aH, 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
no_nak	DB	01H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03fH
	DW	0642H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	025054619H
	DD	0118231dH
	DD	0700b0929H
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	04930H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
main$rtcName$0 DB 069H
	DB	06eH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+1
main$rtcName$1 DB 06fH
	DB	075H
	DB	074H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
main$rtcName$2 DB 061H
	DB	072H
	DB	072H
	DB	069H
	DB	076H
	DB	065H
	DB	064H
	DB	00H
main$rtcName$3 DB 061H
	DB	072H
	DB	067H
	DB	00H
main$rtcName$4 DB 066H
	DB	00H
	ORG $+2
main$rtcVarDesc DD 041b0H
	DD	0108H
	DQ	FLAT:main$rtcName$4
	DD	04184H
	DD	04H
	DQ	FLAT:main$rtcName$3
	DD	040e8H
	DD	020H
	DQ	FLAT:main$rtcName$2
	DD	020d0H
	DD	02000H
	DQ	FLAT:main$rtcName$1
	DD	0b0H
	DD	02000H
	DQ	FLAT:main$rtcName$0
	ORG $+240
main$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:main$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	043H
	DW	0180H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send__frame DD 025054a19H
	DD	011b2320H
	DD	070140043H
	DD	05013H
	DD	imagerel __GSHandlerCheck
	DD	0208H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
send__frame$rtcName$0 DB 073H
	DB	00H
	ORG $+14
send__frame$rtcVarDesc DD 030H
	DD	0108H
	DQ	FLAT:send__frame$rtcName$0
	ORG $+48
send__frame$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:send__frame$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$put_frame DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$between DD 025051b01H
	DD	0116231bH
	DD	0700f001fH
	DD	0500eH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Desktop\Lab1-Windows-VS2019\datalink.c
;	COMDAT main
_TEXT	SEGMENT
ack_expected$ = 4
next_frame_to_send$ = 36
frame_expected$ = 68
too_far$ = 100
in_buf$ = 144
out_buf$ = 8368
arrived$ = 16584
nbuffered$ = 16644
i$8 = 16676
event$ = 16708
arg$ = 16740
f$ = 16784
len$ = 17076
$T9 = 18648
$T10 = 18680
tv74 = 18692
tv90 = 18692
tv208 = 18692
tv225 = 18692
tv231 = 18692
tv273 = 18692
tv183 = 18696
__$ArrayPad$ = 18704
argc$ = 18752
argv$ = 18760
main	PROC						; COMDAT

; 99   : {

$LN42:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	mov	eax, 18760				; 00004948H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 4298				; 000010caH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+18792]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__7E028C7C_datalink@c
	call	__CheckForDebuggerJustMyCode
	npad	1

; 100  : 	// 滑动窗口变量初始化：
; 101  : 	seq_nr ack_expected = 0; // 发送窗口的下限，即下一个未被确认的数据帧序号

	mov	BYTE PTR ack_expected$[rbp], 0

; 102  : 	seq_nr next_frame_to_send =

	mov	BYTE PTR next_frame_to_send$[rbp], 0

; 103  : 		0; // 发送窗口的上限+1，表示下一个要发送的数据帧序号
; 104  : 	seq_nr frame_expected = 0; // 接收窗口的下限，表示期望接收的下一帧序号

	mov	BYTE PTR frame_expected$[rbp], 0

; 105  : 	seq_nr too_far = NR_BUFS;  // 接收窗口的上界+1

	mov	BYTE PTR too_far$[rbp], 32		; 00000020H

; 106  : 
; 107  : 	// 定义发送和接收缓冲区，用于存放数据包
; 108  : 	packet in_buf[NR_BUFS];  // 接收窗口缓冲，用于临时存储接收的帧
; 109  : 	packet out_buf[NR_BUFS]; // 发送窗口缓冲，用于存储待发送的数据包
; 110  : 	boolean arrived
; 111  : 		[NR_BUFS]; // 标记接收缓冲区中每个位置是否已有数据，初始时均为空
; 112  : 	seq_nr nbuffered = 0; // 记录发送但未确认的帧的个数

	mov	BYTE PTR nbuffered$[rbp], 0

; 113  : 
; 114  : 	// 初始化接收缓冲区的标记为0，表示所有位置均为空
; 115  : 	for (int i = 0; i < NR_BUFS; ++i)

	mov	DWORD PTR i$8[rbp], 0
	jmp	SHORT $LN4@main
$LN2@main:
	mov	eax, DWORD PTR i$8[rbp]
	inc	eax
	mov	DWORD PTR i$8[rbp], eax
$LN4@main:
	cmp	DWORD PTR i$8[rbp], 32			; 00000020H
	jge	SHORT $LN3@main

; 116  : 		arrived[i] = 0;

	movsxd	rax, DWORD PTR i$8[rbp]
	mov	QWORD PTR $T9[rbp], rax
	cmp	QWORD PTR $T9[rbp], 32			; 00000020H
	jae	SHORT $LN30@main
	jmp	SHORT $LN31@main
$LN30@main:
	call	__report_rangecheckfailure
	npad	1
$LN31@main:
	mov	rax, QWORD PTR $T9[rbp]
	mov	BYTE PTR arrived$[rbp+rax], 0
	jmp	SHORT $LN2@main
$LN3@main:

; 117  : 
; 118  : 	int event;   // 用于存储事件类型
; 119  : 	int arg;     // 用于存储定时器序号或其它事件参数
; 120  : 	Frame f;     // 用于存储接收到的帧
; 121  : 	int len = 0; // 接收帧的长度

	mov	DWORD PTR len$[rbp], 0

; 122  : 
; 123  : 	// 初始化协议（例如，网络和物理层的设置）
; 124  : 	protocol_init(argc, argv);

	mov	rdx, QWORD PTR argv$[rbp]
	mov	ecx, DWORD PTR argc$[rbp]
	call	protocol_init
	npad	1

; 125  : 	lprintf("Melo && Songshuyu : " __DATE__ "  "__TIME__

	lea	rcx, OFFSET FLAT:??_C@_0CL@LDLCFLN@Melo?5?$CG?$CG?5Songshuyu?5?3?5May?512?52025@
	call	lprintf
	npad	1

; 126  : 		"\n");
; 127  : 
; 128  : 	// 刚开始禁止网络层，以防发送缓冲区满
; 129  : 	disable_network_layer();

	call	disable_network_layer
	npad	1
$LN5@main:

; 130  : 
; 131  : 	// 进入主循环，等待并处理各种事件
; 132  : 	for (;;) {
; 133  : 		// 等待事件发生（如网络层数据、物理层准备好、帧接收等）
; 134  : 		event = wait_for_event(&arg);

	lea	rcx, QWORD PTR arg$[rbp]
	call	wait_for_event
	mov	DWORD PTR event$[rbp], eax

; 135  : 
; 136  : 		switch (event) {

	mov	eax, DWORD PTR event$[rbp]
	mov	DWORD PTR tv74[rbp], eax
	cmp	DWORD PTR tv74[rbp], 0
	je	SHORT $LN14@main
	cmp	DWORD PTR tv74[rbp], 1
	je	$LN15@main
	cmp	DWORD PTR tv74[rbp], 2
	je	$LN16@main
	cmp	DWORD PTR tv74[rbp], 3
	je	$LN25@main
	cmp	DWORD PTR tv74[rbp], 4
	je	$LN26@main
	jmp	$LN8@main
$LN14@main:

; 137  : 		case NETWORK_LAYER_READY:
; 138  : 			// 网络层准备好数据，获取数据包存入发送缓冲区
; 139  : 			get_packet(out_buf[next_frame_to_send % NR_BUFS]);

	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR out_buf$[rbp+rax]
	mov	rcx, rax
	call	get_packet
	npad	1

; 140  : 			nbuffered++; // 增加待发送帧计数

	movzx	eax, BYTE PTR nbuffered$[rbp]
	inc	al
	mov	BYTE PTR nbuffered$[rbp], al

; 141  : 			// 发送数据帧，同时捎带ACK（告知接收方已成功接收的最新帧）
; 142  : 			send__frame(FRAME_DATA, next_frame_to_send,

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, BYTE PTR next_frame_to_send$[rbp]
	mov	cl, 1
	call	send__frame
	npad	1

; 143  : 				    frame_expected, out_buf);
; 144  : 			// 更新发送窗口的上界，注意序号回绕
; 145  : 			inc(next_frame_to_send);

	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	cmp	eax, 63					; 0000003fH
	jge	SHORT $LN32@main
	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	inc	eax
	mov	DWORD PTR tv90[rbp], eax
	jmp	SHORT $LN33@main
$LN32@main:
	mov	DWORD PTR tv90[rbp], 0
$LN33@main:
	movzx	eax, BYTE PTR tv90[rbp]
	mov	BYTE PTR next_frame_to_send$[rbp], al

; 146  : 			break;

	jmp	$LN8@main
$LN15@main:

; 147  : 
; 148  : 		case PHYSICAL_LAYER_READY:
; 149  : 			// 当物理层空闲后，设置标志位，允许继续发送
; 150  : 			phl_ready = 1;

	mov	DWORD PTR phl_ready, 1

; 151  : 			break;

	jmp	$LN8@main
$LN16@main:

; 152  : 
; 153  : 		case FRAME_RECEIVED:
; 154  : 			// 当接收到一帧数据时，调用recv_frame读取数据到f中，并返回数据长度
; 155  : 			len = recv_frame((unsigned char *)&f, sizeof f);

	mov	edx, 264				; 00000108H
	lea	rcx, QWORD PTR f$[rbp]
	call	recv_frame
	mov	DWORD PTR len$[rbp], eax

; 156  : 
; 157  : 			// 检查帧长度是否足够，以及CRC校验是否通过，确保数据未被破坏
; 158  : 			if (len < 6 || crc32((unsigned char *)&f, len) != 0) {

	cmp	DWORD PTR len$[rbp], 6
	jl	SHORT $LN18@main
	mov	edx, DWORD PTR len$[rbp]
	lea	rcx, QWORD PTR f$[rbp]
	call	crc32
	test	eax, eax
	je	SHORT $LN17@main
$LN18@main:

; 159  : 				dbg_event(

	lea	rcx, OFFSET FLAT:??_C@_0BP@BDPEBLLD@?$CK?$CK?$CK?$CK?5?5Error?0?5Bad?5CRC?5Checksum?6@
	call	dbg_event
	npad	1

; 160  : 					"****  Error, Bad CRC Checksum\n");
; 161  : 				// 出现错误且之前未发送NAK，发送NAK请求重传
; 162  : 				if (no_nak) {

	movzx	eax, BYTE PTR no_nak
	test	eax, eax
	je	SHORT $LN19@main

; 163  : 					send__frame(FRAME_NAK, 0,

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 3
	call	send__frame
	npad	1
$LN19@main:

; 164  : 						    frame_expected, out_buf);
; 165  : 				}
; 166  : 				// 错误帧直接丢弃，不进行进一步处理
; 167  : 				break;

	jmp	$LN8@main
$LN17@main:

; 168  : 			}
; 169  : 
; 170  : 			// 处理ACK帧：仅记录ACK信息，并打印调试信息
; 171  : 			if (f.kind == FRAME_ACK)

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 2
	jne	SHORT $LN20@main

; 172  : 				dbg_frame("Recv ACK  %d\n", f.ack);

	movzx	eax, BYTE PTR f$[rbp+1]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
	call	dbg_frame
	npad	1
$LN20@main:

; 173  : 
; 174  : 			// 处理数据帧
; 175  : 			if (f.kind == FRAME_DATA) {

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 1
	jne	$LN21@main

; 176  : 				dbg_frame("Recv DATA %d %d, ID %d\n", f.seq,

	movsx	eax, WORD PTR f$[rbp+3]
	movzx	ecx, BYTE PTR f$[rbp+1]
	movzx	edx, BYTE PTR f$[rbp+2]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	dbg_frame
	npad	1

; 177  : 					  f.ack, *(short *)f.data);
; 178  : 
; 179  : 				// 如果接收到的帧序号不是期望的，并且之前没有发送NAK，则主动发送NAK请求重传
; 180  : 				if (f.seq != frame_expected && no_nak) {

	movzx	eax, BYTE PTR f$[rbp+2]
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	cmp	eax, ecx
	je	SHORT $LN22@main
	movzx	eax, BYTE PTR no_nak
	test	eax, eax
	je	SHORT $LN22@main

; 181  : 					dbg_event(

	lea	rcx, OFFSET FLAT:??_C@_0CM@EIMHPHCN@Recv?5frame?5is?5not?5?5expected?0?5NA@
	call	dbg_event
	npad	1

; 182  : 						"Recv frame is not  expected, NAK sent back\n");
; 183  : 					send__frame(FRAME_NAK, 0,

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 3
	call	send__frame
	npad	1
$LN22@main:

; 184  : 						    frame_expected, out_buf);
; 185  : 				}
; 186  : 
; 187  : 				// 判断接收到的帧是否在当前接收窗口内，并且该缓冲区位置还未被占用
; 188  : 				if (between(frame_expected, f.seq, too_far) &&

	movzx	r8d, BYTE PTR too_far$[rbp]
	movzx	edx, BYTE PTR f$[rbp+2]
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	call	between
	movzx	eax, al
	test	eax, eax
	je	$LN23@main
	movzx	eax, BYTE PTR f$[rbp+2]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	movzx	eax, BYTE PTR arrived$[rbp+rax]
	test	eax, eax
	jne	$LN23@main

; 189  : 				    (arrived[f.seq % NR_BUFS] == 0)) {
; 190  : 					arrived[f.seq % NR_BUFS] =

	movzx	eax, BYTE PTR f$[rbp+2]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	mov	BYTE PTR arrived$[rbp+rax], 1

; 191  : 						1; // 标记该位置已接收数据
; 192  : 
; 193  : 					// 注意：len = PKT_LEN + 3 + 4 (CRC) - 4，所以数据长度为 len - 7
; 194  : 					memcpy(in_buf[f.seq % NR_BUFS], f.data,

	mov	eax, DWORD PTR len$[rbp]
	sub	eax, 7
	cdqe
	mov	QWORD PTR tv183[rbp], rax
	movzx	ecx, BYTE PTR f$[rbp+2]
	mov	eax, ecx
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR in_buf$[rbp+rax]
	mov	rcx, QWORD PTR tv183[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR f$[rbp+3]
	mov	rcx, rax
	call	memcpy
	npad	1
$LN10@main:

; 195  : 					       len - 7);
; 196  : 
; 197  : 					// 当接收缓冲中从期望帧开始连续有数据时，交付网络层，并更新窗口
; 198  : 					while (arrived[frame_expected %

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	movzx	eax, BYTE PTR arrived$[rbp+rax]
	test	eax, eax
	je	$LN11@main

; 199  : 						       NR_BUFS]) {
; 200  : 						dbg_event(

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	movsx	eax, WORD PTR in_buf$[rbp+rax]
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:??_C@_0CM@ILJEGABI@Put?5packet?5to?5network?5layer?5seq@
	call	dbg_event
	npad	1

; 201  : 							"Put packet to network layer seq:%d, ID: %d\n",
; 202  : 							frame_expected,
; 203  : 							*(short *)(in_buf[frame_expected %
; 204  : 									  NR_BUFS]));
; 205  : 						put_packet(

	mov	eax, DWORD PTR len$[rbp]
	sub	eax, 7
	mov	DWORD PTR tv208[rbp], eax
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	mov	eax, ecx
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR in_buf$[rbp+rax]
	mov	ecx, DWORD PTR tv208[rbp]
	mov	edx, ecx
	mov	rcx, rax
	call	put_packet
	npad	1

; 206  : 							in_buf[frame_expected %
; 207  : 							       NR_BUFS],
; 208  : 							len - 7);
; 209  : 						arrived[frame_expected %

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	mov	QWORD PTR $T10[rbp], rax
	cmp	QWORD PTR $T10[rbp], 32			; 00000020H
	jae	SHORT $LN34@main
	jmp	SHORT $LN35@main
$LN34@main:
	call	__report_rangecheckfailure
	npad	1
$LN35@main:
	mov	rax, QWORD PTR $T10[rbp]
	mov	BYTE PTR arrived$[rbp+rax], 0

; 210  : 							NR_BUFS] =
; 211  : 							0; // 释放缓冲区位置
; 212  : 						no_nak =

	mov	BYTE PTR no_nak, 1

; 213  : 							1; // 交付后，重置NAK标志
; 214  : 						inc(frame_expected); // 窗口下界前移

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cmp	eax, 63					; 0000003fH
	jge	SHORT $LN36@main
	movzx	eax, BYTE PTR frame_expected$[rbp]
	inc	eax
	mov	DWORD PTR tv225[rbp], eax
	jmp	SHORT $LN37@main
$LN36@main:
	mov	DWORD PTR tv225[rbp], 0
$LN37@main:
	movzx	eax, BYTE PTR tv225[rbp]
	mov	BYTE PTR frame_expected$[rbp], al

; 215  : 						inc(too_far); // 窗口上界前移

	movzx	eax, BYTE PTR too_far$[rbp]
	cmp	eax, 63					; 0000003fH
	jge	SHORT $LN38@main
	movzx	eax, BYTE PTR too_far$[rbp]
	inc	eax
	mov	DWORD PTR tv231[rbp], eax
	jmp	SHORT $LN39@main
$LN38@main:
	mov	DWORD PTR tv231[rbp], 0
$LN39@main:
	movzx	eax, BYTE PTR tv231[rbp]
	mov	BYTE PTR too_far$[rbp], al

; 216  : 						// 每交付一帧就启动ACK定时器，确保ACK能及时发送
; 217  : 						start_ack_timer(ACK_TIMER);

	mov	ecx, 290				; 00000122H
	call	start_ack_timer
	npad	1

; 218  : 					}

	jmp	$LN10@main
$LN11@main:
$LN23@main:
$LN21@main:

; 219  : 				}
; 220  : 			}
; 221  : 
; 222  : 			// 处理NAK帧：如果收到NAK，且被请求重传的帧在发送窗口中，则重发该帧
; 223  : 			if (f.kind == FRAME_NAK &&

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 3
	jne	$LN24@main
	movzx	eax, BYTE PTR f$[rbp+1]
	inc	eax
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx
	movzx	r8d, BYTE PTR next_frame_to_send$[rbp]
	movzx	edx, al
	movzx	ecx, BYTE PTR ack_expected$[rbp]
	call	between
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@main

; 224  : 			    between(ack_expected, (f.ack + 1) % (MAX_SEQ + 1),
; 225  : 				    next_frame_to_send)) {
; 226  : 				dbg_frame("Recv NAK  %d --%dbyte\n",

	movzx	eax, BYTE PTR f$[rbp+1]
	inc	eax
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx
	mov	r8d, DWORD PTR len$[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0BH@LFIEOPPF@Recv?5NAK?5?5?$CFd?5?9?9?$CFdbyte?6@
	call	dbg_frame
	npad	1

; 227  : 					  (f.ack + 1) % (MAX_SEQ + 1), len);
; 228  : 				// 重发被NAK请求的帧
; 229  : 				send__frame(FRAME_DATA,

	movzx	eax, BYTE PTR f$[rbp+1]
	inc	eax
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx
	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, al
	mov	cl, 1
	call	send__frame
	npad	1
$LN24@main:
$LN12@main:

; 230  : 					    (f.ack + 1) % (MAX_SEQ + 1),
; 231  : 					    frame_expected, out_buf);
; 232  : 			}
; 233  : 
; 234  : 			// 处理累计确认：通过一个循环，利用收到的（可能带有累计确认信息的）ACK f.ack，
; 235  : 			// 逐个处理从当前窗口下界 ack_expected 开始的、所有已被该 ACK 确认的帧。每处理一个帧，
; 236  : 			// 就减少缓存计数、停止其定时器，并将窗口下界向前推进一步。
; 237  : 			// 直到 ack_expected 指向一个尚未被 f.ack 确认的帧时，循环停止
; 238  : 			while (between(ack_expected, f.ack,

	movzx	r8d, BYTE PTR next_frame_to_send$[rbp]
	movzx	edx, BYTE PTR f$[rbp+1]
	movzx	ecx, BYTE PTR ack_expected$[rbp]
	call	between
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@main

; 239  : 				       next_frame_to_send)) {
; 240  : 				nbuffered--;              // 减少待确认计数

	movzx	eax, BYTE PTR nbuffered$[rbp]
	dec	al
	mov	BYTE PTR nbuffered$[rbp], al

; 241  : 				stop_timer(ack_expected); // 停止对应定时器

	movzx	eax, BYTE PTR ack_expected$[rbp]
	mov	ecx, eax
	call	stop_timer
	npad	1

; 242  : 				inc(ack_expected);        // 发送窗口下界前移

	movzx	eax, BYTE PTR ack_expected$[rbp]
	cmp	eax, 63					; 0000003fH
	jge	SHORT $LN40@main
	movzx	eax, BYTE PTR ack_expected$[rbp]
	inc	eax
	mov	DWORD PTR tv273[rbp], eax
	jmp	SHORT $LN41@main
$LN40@main:
	mov	DWORD PTR tv273[rbp], 0
$LN41@main:
	movzx	eax, BYTE PTR tv273[rbp]
	mov	BYTE PTR ack_expected$[rbp], al

; 243  : 			}

	jmp	SHORT $LN12@main
$LN13@main:

; 244  : 			break;

	jmp	SHORT $LN8@main
$LN25@main:

; 245  : 
; 246  : 		case DATA_TIMEOUT:
; 247  : 			// 数据帧超时：说明对应帧的ACK未能及时收到，触发重传机制
; 248  : 			dbg_event("---- DATA %d timeout, resend ----\n", arg);

	mov	edx, DWORD PTR arg$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CD@MEKNEOEC@?9?9?9?9?5DATA?5?$CFd?5timeout?0?5resend?5?9?9@
	call	dbg_event
	npad	1

; 249  : 			send__frame(FRAME_DATA, arg, frame_expected, out_buf);

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, BYTE PTR arg$[rbp]
	mov	cl, 1
	call	send__frame
	npad	1

; 250  : 			break;

	jmp	SHORT $LN8@main
$LN26@main:

; 251  : 
; 252  : 		case ACK_TIMEOUT:
; 253  : 			// ACK定时器超时：及时发送独立ACK帧，确保通信双方同步
; 254  : 			send__frame(FRAME_ACK, 0, frame_expected, out_buf);

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 2
	call	send__frame
	npad	1
$LN8@main:

; 255  : 			break;
; 256  : 		}
; 257  : 
; 258  : 		// 流量控制：如果发送窗口未满且物理层准备好，则通知网络层继续发送数据
; 259  : 		if (nbuffered < NR_BUFS && phl_ready)

	movzx	eax, BYTE PTR nbuffered$[rbp]
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN27@main
	cmp	DWORD PTR phl_ready, 0
	je	SHORT $LN27@main

; 260  : 			enable_network_layer();

	call	enable_network_layer
	npad	1
	jmp	SHORT $LN28@main
$LN27@main:

; 261  : 		else
; 262  : 			disable_network_layer();

	call	disable_network_layer
	npad	1
$LN28@main:

; 263  : 	}

	jmp	$LN5@main
$LN29@main:

; 264  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:main$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+18728]
	pop	rdi
	pop	rbp
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Desktop\Lab1-Windows-VS2019\datalink.c
;	COMDAT send__frame
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 488
fk$ = 528
frame_nr$ = 536
frame_expected$ = 544
buffer$ = 552
send__frame PROC					; COMDAT

; 64   : {

	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 536				; 00000218H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+568]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__7E028C7C_datalink@c
	call	__CheckForDebuggerJustMyCode
	npad	1

; 65   : 	Frame s; // 临时帧变量，用于构造要发送的帧
; 66   : 
; 67   : 	s.kind = fk;

	movzx	eax, BYTE PTR fk$[rbp]
	mov	BYTE PTR s$[rbp], al

; 68   : 	s.seq = frame_nr;

	movzx	eax, BYTE PTR frame_nr$[rbp]
	mov	BYTE PTR s$[rbp+2], al

; 69   : 	// 计算ACK值：当前接收窗口下界的前一个帧的序号作为ACK值返回
; 70   : 	// 这里采用了模运算以适应序号循环的特性
; 71   : 	s.ack = (frame_expected + MAX_SEQ) % (MAX_SEQ + 1);

	movzx	eax, BYTE PTR frame_expected$[rbp]
	add	eax, 63					; 0000003fH
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx
	mov	BYTE PTR s$[rbp+1], al

; 72   : 	// 一旦ACK捎带发送，就停止ACK定时器，这有助于减少不必要的重复ACK
; 73   : 	stop_ack_timer();

	call	stop_ack_timer
	npad	1

; 74   : 
; 75   : 	if (fk == FRAME_DATA) {

	movzx	eax, BYTE PTR fk$[rbp]
	cmp	eax, 1
	jne	SHORT $LN2@send__fram

; 76   : 		// 数据帧：从发送缓冲区中拷贝出对应的数据到帧中
; 77   : 		memcpy(s.data, buffer[frame_nr % NR_BUFS], PKT_LEN);

	movzx	eax, BYTE PTR frame_nr$[rbp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	mov	rcx, QWORD PTR buffer$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8d, 256				; 00000100H
	mov	rdx, rax
	lea	rcx, QWORD PTR s$[rbp+3]
	call	memcpy
	npad	1

; 78   : 
; 79   : 		dbg_frame("We Send DATA %d %d, ID %d\n", s.seq, s.ack,

	movsx	eax, WORD PTR s$[rbp+3]
	movzx	ecx, BYTE PTR s$[rbp+1]
	movzx	edx, BYTE PTR s$[rbp+2]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:??_C@_0BL@MJDEAOHC@We?5Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	dbg_frame
	npad	1

; 80   : 			  *(short *)s.data);
; 81   : 		// 发送数据帧：这里的3为frame_kind, seq和ack三个字节，加上数据部分长度
; 82   : 		put_frame((unsigned char *)&s, 3 + PKT_LEN);

	mov	edx, 259				; 00000103H
	lea	rcx, QWORD PTR s$[rbp]
	call	put_frame
	npad	1

; 83   : 		// 开始数据帧定时器，等待对该帧的ACK；如果超时则会重传
; 84   : 		start_timer(frame_nr, DATA_TIMER);

	movzx	eax, BYTE PTR frame_nr$[rbp]
	mov	edx, 2500				; 000009c4H
	mov	ecx, eax
	call	start_timer
	npad	1
	jmp	SHORT $LN3@send__fram
$LN2@send__fram:

; 85   : 	} else if (fk == FRAME_ACK) {

	movzx	eax, BYTE PTR fk$[rbp]
	cmp	eax, 2
	jne	SHORT $LN4@send__fram

; 86   : 		// ACK帧：仅包含帧类型和ACK序号，数据部分不发送
; 87   : 		dbg_frame("We Send ACK  %d\n", s.ack);

	movzx	eax, BYTE PTR s$[rbp+1]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0BB@HNIKDDHJ@We?5Send?5ACK?5?5?$CFd?6@
	call	dbg_frame
	npad	1

; 88   : 		put_frame((unsigned char *)&s, 2);

	mov	edx, 2
	lea	rcx, QWORD PTR s$[rbp]
	call	put_frame
	npad	1

; 89   : 	} else {

	jmp	SHORT $LN5@send__fram
$LN4@send__fram:

; 90   : 		// NAK帧：用于请求重传错误帧。注意：NAK的序号为当前期望的帧序号
; 91   : 		dbg_frame("We Send NAK  %d\n", frame_expected);

	movzx	eax, BYTE PTR frame_expected$[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0BB@OABGPLNF@We?5Send?5NAK?5?5?$CFd?6@
	call	dbg_frame
	npad	1

; 92   : 		no_nak = 0; // 标记已经发送过NAK，避免重复发送

	mov	BYTE PTR no_nak, 0

; 93   : 		put_frame((unsigned char *)&s, 2);

	mov	edx, 2
	lea	rcx, QWORD PTR s$[rbp]
	call	put_frame
	npad	1
$LN5@send__fram:
$LN3@send__fram:

; 94   : 	}
; 95   : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:send__frame$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+504]
	pop	rdi
	pop	rbp
	ret	0
send__frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Desktop\Lab1-Windows-VS2019\datalink.c
;	COMDAT put_frame
_TEXT	SEGMENT
frame$ = 224
len$ = 232
put_frame PROC						; COMDAT

; 51   : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7E028C7C_datalink@c
	call	__CheckForDebuggerJustMyCode
	npad	1

; 52   : 	// 将CRC32校验码放在帧末尾（4字节），方便接收方检测传输错误
; 53   : 	*(unsigned int *)(frame + len) = crc32(frame, len);

	mov	edx, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR frame$[rbp]
	call	crc32
	movsxd	rcx, DWORD PTR len$[rbp]
	mov	rdx, QWORD PTR frame$[rbp]
	mov	DWORD PTR [rdx+rcx], eax

; 54   : 	// 发送帧（数据+校验码）
; 55   : 	send_frame(frame, len + 4);

	mov	eax, DWORD PTR len$[rbp]
	add	eax, 4
	mov	edx, eax
	mov	rcx, QWORD PTR frame$[rbp]
	call	send_frame
	npad	1

; 56   : 	// 发送后默认认为物理层缓存已满，需要等待物理层回调通知
; 57   : 	phl_ready = 0;

	mov	DWORD PTR phl_ready, 0

; 58   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
put_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Desktop\Lab1-Windows-VS2019\datalink.c
;	COMDAT between
_TEXT	SEGMENT
tv82 = 192
a$ = 240
b$ = 248
c$ = 256
between	PROC						; COMDAT

; 44   : {

	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7E028C7C_datalink@c
	call	__CheckForDebuggerJustMyCode
	npad	1

; 45   : 	return ((a <= b && b < c) || (c < a && b < c) || (c < a && a <= b));

	movzx	eax, BYTE PTR a$[rbp]
	movzx	ecx, BYTE PTR b$[rbp]
	cmp	eax, ecx
	jg	SHORT $LN3@between
	movzx	eax, BYTE PTR b$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	cmp	eax, ecx
	jl	SHORT $LN5@between
$LN3@between:
	movzx	eax, BYTE PTR c$[rbp]
	movzx	ecx, BYTE PTR a$[rbp]
	cmp	eax, ecx
	jge	SHORT $LN4@between
	movzx	eax, BYTE PTR b$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	cmp	eax, ecx
	jl	SHORT $LN5@between
$LN4@between:
	movzx	eax, BYTE PTR c$[rbp]
	movzx	ecx, BYTE PTR a$[rbp]
	cmp	eax, ecx
	jge	SHORT $LN6@between
	movzx	eax, BYTE PTR a$[rbp]
	movzx	ecx, BYTE PTR b$[rbp]
	cmp	eax, ecx
	jle	SHORT $LN5@between
$LN6@between:
	mov	DWORD PTR tv82[rbp], 0
	jmp	SHORT $LN7@between
$LN5@between:
	mov	DWORD PTR tv82[rbp], 1
$LN7@between:
	movzx	eax, BYTE PTR tv82[rbp]

; 46   : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
between	ENDP
_TEXT	ENDS
END
